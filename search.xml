<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019年12月份四六级密押卷已出，速取 ☆☆☆热☆☆☆]]></title>
    <url>%2F2019%2F12%2F06%2F008%E5%9B%9B%E5%85%AD%E7%BA%A7%E5%AF%86%E6%8A%BC%E5%8D%B7%2F</url>
    <content type="text"><![CDATA[资料：四级压题卷：20元，六级押题卷：21元，在文章底部扫码付款后可获取密码，然后回到主页紧接下一个文章提取百度网盘资源，有问题可私聊qq：409011616不要担心距离四六级考试还有几天，找我就对了！！1、资源来之不易，重要程度可想而知2、基础知识掌握后，请认真作答该套密卷3、拿到资料后，大家不要再迷失方向，胡乱找资料，看网课，这些都没用，只会耽误时间！！！抓紧时机看我的资料 保证没问题！！！4、最后，我祝愿大家能够考出一个好成绩！5、如有问题可以问我，我为大家排忧解难！！！我与大家同在！！！（企鹅及时联系）6、在线客服qq:409011616]]></content>
      <categories>
        <category>考试</category>
      </categories>
      <tags>
        <tag>四六级考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马C/C++24期高清完整版 ☆☆☆全新☆☆☆]]></title>
    <url>%2F2019%2F12%2F02%2F007C%2B%2B24%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[全套25.5元！！！有问题可私聊qq：409011616百度网盘链接：https://pan.baidu.com/s/.........................出现bug,如果已经付款，请咨询qq409011616....................................................提取码：a8vz请联系qq409011616]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马C/C++24期高清完整版 ☆☆☆全新☆☆☆]]></title>
    <url>%2F2019%2F12%2F02%2F007%E9%BB%91%E9%A9%ACC%2B%2B24%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[全套25.5元！！！高清无加密在文章底部扫码付款后可获取密码，然后回到主页紧接下一个文章提取百度网盘网盘，有问题可私聊qq：409011616├─01c基础│ ├─01-C基础第01天（linux介绍和基本命令）│ │ ├─01笔记│ │ │ 笔记.txt│ │ ││ │ ├─03视频│ │ │ 01Linux操作系统介绍│ │ │ 02Linux版本和应用│ │ │ 03目录和文件以及文件分类│ │ │ 04文件权限│ │ │ 05命令格式和快捷提示│ │ │ 06查看文件命令和重定向│ │ │ 07切换工作目录│ │ │ 08创建目录和删除目录│ │ │ 09链接文件│ │ │ 10文本搜索│ │ │ 12文件搜索│ │ │ 13复制、移动和格式│ │ │ 14归档压缩│ │ │ 15bzip2、zip压缩│ │ ││ │ └─04资料│ │ │ 01_Linux介绍和基本操作.png│ │ │ CMD.txt│ │ │ c语言32个关键字.pdf│ │ │ Linux C 函数.chm│ │ │ Linux命令大全.chm│ │ │ LINUX常用命令.pdf│ │ │ UnixLinux基础讲义.doc│ │ ││ │ └─02_学习方法│ │ 如何学习一些需要算法的程序.doc│ │ 如何学习一门新语言（针对初学者）.doc│ ││ ├─01-C基础第02天（用户权限、VI操作、Linux服务器搭建）│ │ ├─01笔记│ │ │ DD.png│ │ │ 笔记.txt│ │ ││ │ ├─03视频│ │ │ 01总结│ │ │ 02用户权限和切换工作目录│ │ │ 03新建组和用户│ │ │ 04修改文件权限和用户组│ │ │ 05进程查看和后台管理│ │ │ 06系统管理和网络状态│ │ │ 07vi编辑器基本操作│ │ │ 08vi的删除和修改功能│ │ │ 09vi的行定位和文本定位│ │ │ 10vi的替换和设置│ │ │ 11远程连接│ │ │ 12远程文件传输│ │ │ 14Linux服务器搭建│ │ │ 15手写网页│ │ ││ │ ├─03视频(新)│ │ │ 01回顾│ │ │ 02查看和切换用户│ │ │ 03创建工作组和修改用户所在组│ │ │ 04创建删除用户│ │ │ 05修改文件权限│ │ │ 06系统相关命令│ │ │ 07VI基本操作上│ │ │ 08VI基本操作中│ │ │ 09VI基本操作下│ │ │ 10建立远程登录│ │ │ 11上传下载│ │ │ 12创建网页│ │ │ 12远程服务器搭建│ │ ││ │ └─04资料│ ││ ├─01-C基础第03天（Helloworld）│ │ └─01-C基础第03天（Helloworld）│ │ ├─01笔记│ │ │ │ 1、Hello World代码分析：.html│ │ │ │ 程序执行过程.png│ │ │ │ 程序编译过程.png│ │ │ ││ │ │ └─1、Hello World代码分析：_files│ │ │ Image.png│ │ ││ │ ├─02代码│ │ ││ │ ├─03视频│ │ │ 00早读英语│ │ │ 01总结_cX5e8│ │ │ 02C语言学习结构│ │ │ 03计算机组成│ │ │ 04语言的发展│ │ │ 05C语言关键字│ │ │ 06helloworld│ │ │ 07系统调用函数system│ │ │ 08QT下图形化界面│ │ │ 09VS下图形化界面│ │ │ 10程序编译和执行过程│ │ │ 11cpu与内存│ │ │ 12反汇编│ │ │ 13IDE快捷键使用和问题处理│ │ ││ │ └─04资料│ │ 03_C语言概述.png│ │ Depends.exe│ ││ ├─01-C基础第04天（数据类型与运算符）│ │ └─01-C基础第04天（数据类型与运算符）│ │ ├─01笔记│ │ │ 10转2.png│ │ │ 16转化任意进制.png│ │ │ 1、数据类型的定义.html│ │ │ 2转10.png│ │ │ 8转2、2转8.png│ │ ││ │ ├─02代码│ │ │ 01变量常量的定义.i│ │ │ 02各个进制数的表示.c│ │ │ 03数据类型在内存的大小.c│ │ │ 04格式化输入输出.c│ │ │ 07课堂代码练习.c│ │ │ 08浮点型数据操作.c│ │ ││ │ ├─03视频│ │ │ 01早读英语│ │ │ 02总结│ │ │ 03数据类型的定义│ │ │ 04十进制转化为二进制│ │ │ 05二进制转化为十进制│ │ │ 06八进制二进制相互转化│ │ │ 07十六进制的转化│ │ │ 08在程序中进制打印│ │ │ 09源码反码补码和sizeof│ │ │ 10源码反码补码和sizeof补充说明│ │ │ 11练习：年份减月日│ │ │ 12有符号和无符号的取值范围│ │ │ 13字符类型│ │ │ 14数值溢出│ │ │ 15浮点型│ │ │ 16字符串的格式化输入输出│ │ │ 17总结│ │ ││ │ └─04资料│ │ 04_数据类型.png│ │ ASCII码对照表.doc│ │ 课后练习题.docx│ ││ ├─01-C基础第05天（运算符和流程结构语句）│ │ └─01-C基础第05天（运算符和流程结构语句）│ │ ├─01笔记│ │ │ 01if语句.png│ │ │ 02ifelse语句.png│ │ │ 03三只小猪.png│ │ │ 04while循环.png│ │ │ 05for循环和嵌套循环.png│ │ │ 运算符表达式和流程控制语句.html│ │ ││ │ ├─02代码│ │ ││ │ ├─03视频│ │ │ 01早读英语_5JsDz│ │ │ 02总结_boAhV│ │ │ 03运算符表达式│ │ │ 04运算符的有限级别│ │ │ 05类型转换│ │ │ 06if条件语句│ │ │ 07三只小猪称体重│ │ │ 08三木运算符│ │ │ 09switch语句│ │ │ 10while循环语句和敲7│ │ │ 11dowhile语句和水仙花│ │ │ 12for循环和水仙花│ │ │ 13嵌套循环│ │ │ 14九九乘法口诀│ │ │ 15猜数字│ │ │ 16goto语句│ │ ││ │ └─04资料│ │ 课后练习题.docx│ ││ ├─01-C基础第06天（数组）│ │ └─01-C基础第06天（数组）│ │ ├─01笔记│ │ │ │ 00打印星星.png│ │ │ │ 01数组的定义和初始化.png│ │ │ │ 01笔记.rar│ │ │ │ 02数组内存结构.png│ │ │ │ 03冒泡排序.png│ │ │ │ 04二维数组内存模型.png│ │ │ │ 05字符数组和字符串在内存中不同的存储方式.png│ │ │ │ 06字符串连接.png│ │ │ │ 数组.html│ │ │ ││ │ │ └─数组_files│ │ │ Image.png│ │ ││ │ ├─02代码│ │ ││ │ ├─03视频│ │ │ 01早读英语_6KITH│ │ │ 02课后练习题│ │ │ 03总结│ │ │ 04数组的定义和使用│ │ │ 05数组初始化和内存结构│ │ │ 06十只小猪称体重│ │ │ 07数组逆置│ │ │ 08冒泡排序│ │ │ 09二维数组的定义、使用和内存模型│ │ │ 10二维数组初始化│ │ │ 11二维数组学生成绩│ │ │ 12多维数组│ │ │ 13字符数组│ │ │ 14字符数组的输入│ │ │ 15字符串追加│ │ │ 16双色球│ │ │ 17案例总结│ │ ││ │ └─04资料│ │ 课后练习题.docx│ ││ ├─01-C基础第07天（字符串处理函数和函数）│ │ └─01-C基础第07天（字符串处理函数和函数）│ │ ├─01笔记│ │ │ 01fgets.png│ │ │ 02函数封装模型.png│ │ │ 03程序执行流程.png│ │ │ 11笔记.html│ │ ││ │ ├─02代码│ │ ││ │ ├─03视频│ │ │ 01早读英语_qwAeE│ │ │ 02总结_g7nQi│ │ │ 03标准输入输出│ │ │ 04strlen和strcpy│ │ │ 05strcat函数和strcmp函数│ │ │ 06字符串的格式化输入输出│ │ │ 07strchr函数和strstr函数│ │ │ 08字符串切割│ │ │ 09字符串转换│ │ │ 10函数的定义使用│ │ │ 11函数的声明、定义、调用、四则运算和返回值、参数列表│ │ │ 12函数样式│ │ │ 13多文件联合编程│ │ │ 14mian函数的参数应用│ │ │ EV~2017.03.06~08.58.33│ │ ││ │ └─04资料│ │ 课后练习题.docx│ ││ ├─01-C基础第08天（指针上）│ │ ├─01笔记│ │ │ 01变量的存储格式.png│ │ │ 03指针指向变量和赋值操作.png│ │ │ 04const修饰指针类型.png│ │ │ 05const修饰指针变量.png│ │ │ 07指针和数组关系.png│ │ │ 08多级指针推论.png│ │ │ 指针1笔记.html│ │ ││ │ ├─03视频│ │ │ 01课后练习题│ │ │ 02总结_QMmoc│ │ │ 03指针定义和使用│ │ │ 04指针讲解1│ │ │ 05指针讲解2│ │ │ 06野指针空指针万能指针│ │ │ 07野指针空指针万能指针讲解│ │ │ 08const修饰指针│ │ │ 09const修饰内容│ │ │ 10指针和数组、指针运算│ │ │ 11指针实现冒泡排序│ │ │ 12实现strchr函数│ │ │ 13字符串反转│ │ │ 14指针数组│ │ │ 15多级指针│ │ ││ │ └─04资料│ │ 课后练习题.docx│ ││ ├─01-C基础第09天（指针下）│ │ └─01-C基础第09天（指针下）│ │ ├─01笔记│ │ ││ │ ├─02代码│ │ ││ │ └─03视频│ │ 01早读英语_aziy6│ │ 02总结_AVZM4│ │ 03指针和参数│ │ 04指针作为函数返回值│ │ 05实现strstr函数│ │ 06strstr优化│ │ 07指针和字符串│ │ 08实现strcat函数│ │ 09指针总结│ │ 10字符串排序│ ││ ├─01-C基础第10天（内存结构）│ │ └─01-C基础第10天（内存结构）│ │ ├─01笔记│ │ │ │ 01作用域和声明周期.png│ │ │ │ 02内存四区模型.png│ │ │ │ 03内存增长模型.png│ │ │ │ 05memcmp比对不同类型变量.png│ │ │ │ 06练习题思路.png│ │ │ │ 07栈规则.png│ │ │ ││ │ │ └─笔记│ │ ││ │ ├─02代码│ │ ││ │ ├─03视频│ │ │ 01早读英语_fF8bl│ │ │ 02总结_qz1kJ│ │ │ 03全局变量和局部变量│ │ │ 04静态、声明、函数│ │ │ 05作用域和声明周期│ │ │ 06内存四区模型│ │ │ 07数据存储范围和内存存储方向│ │ │ 08堆空间冒泡排序│ │ │ 08开辟堆空间和堆空间常见错误.c│ │ │ 09对空间操作字符串│ │ │ 10内存处理函数上│ │ │ 11内存处理函数下│ │ │ 12练习题思路讲解│ │ │ EV~2017.03.12~17.13.11│ │ ││ │ └─04资料│ │ 打字游戏.c│ │ 课后练习题.docx│ ││ ├─01-C基础第11天（复合类型）│ │ └─01-C基础第11天（复合类型）│ │ ├─01笔记│ │ ││ │ ├─02代码│ │ ││ │ └─03视频│ │ 01早读英语_RtV8j│ │ 02总结_wTDMA│ │ 03结构体定义和使用│ │ 04结构体大小和内存存储结构│ │ 05结构体数组│ │ 06结构体排序│ │ 07结构体数组排序优化│ │ 08结构体和指针│ │ 09堆空间创建结构体学生成绩│ │ 10结构体和函数│ │ 11学生成绩结构体函数实现│ │ 12结构体嵌套│ │ 13共用体│ │ 14枚举│ │ 15typedef类型定义│ │ 16打字游戏│ │ 17QT版本打字游戏│ │ 2017.03.13.09.04.26│ ││ ├─01-C基础第12天（文件上）│ │ └─01-C基础第12天（文件上）│ │ ├─01笔记│ │ ││ │ ├─02代码│ │ ││ │ ├─03视频│ │ │ 02总结_AeE0O│ │ │ 03文件打开关闭和字符读写│ │ │ 04VI编辑器│ │ │ 05VI编辑器│ │ │ 06cat实现│ │ │ 07四则运算│ │ │ 08四则运算│ │ │ 09加密解密│ │ │ 10加密算法介绍│ │ │ 11文件行读取│ │ │ 12四则运算计算结果│ │ │ 13格式化输入输出│ │ │ 14四则运算│ │ │ 15四则运算│ │ │ 16大数据排序│ │ ││ │ ├─04资料│ │ │ 课后练习题.docx│ │ ││ │ └─12day文件操作│ │ 06四则运算.c│ │ 07文件的加密和解密.c│ │ 09四则运算.c│ │ 12四则运算.c│ │ 13四则运算.c│ ││ ├─01-C基础第13天（文件下）│ │ └─01-C基础第13天（文件下）│ │ ├─01笔记│ │ ││ │ ├─02代码│ │ ││ │ ├─03视频│ │ │ 01早读英语_D5FIO│ │ │ 02总结_pn9Qq│ │ │ 03二进制文件的读写│ │ │ 04大文件拷贝│ │ │ 05大文件拷贝│ │ │ 06文件光标操作│ │ │ 07文件删除重命名移动│ │ │ 08文件缓冲区│ │ │ 09知识点总结│ │ │ 10入侵案例│ │ │ 2017.03.16.11.33.20│ │ │ 2017.03.16.11.39.18│ │ │ 2017.03.16.15.28.35│ │ ││ │ ├─04资料│ │ │ │ a.txt│ │ │ │ app.ico│ │ │ │ app1.ico│ │ │ │ pass.txt│ │ │ │ Qt开发入门教程01-Qt开发基础.pdf│ │ │ │ 如何在linux下开启FTP服务.docx│ │ │ │ 课后练习题.docx│ │ │ ││ │ │ ├─LogViewPro│ │ │ │ LogView.ini│ │ │ │ LogViewPro.CHS│ │ │ │ LogViewPro.exe│ │ │ ││ │ │ └─千万用户密码字典│ │ │ └─千万WiFi密码字典│ │ │ 14365003.txt│ │ ││ │ └─13day│ │ │ 02UI界面搭建│ │ │ 03文件打开│ │ │ 05文件编译│ │ │ 文件保存和编辑功能.txt│ │ │ 文件编译.txt│ │ ││ │ └─0223-IDE│ │ 0223-IDE.pro│ │ 0223-IDE.pro.user│ │ app.ico│ │ main.cpp│ │ mainwindow.cpp│ │ mainwindow.h│ │ mainwindow.ui│ ││ ├─01-C基础第14天（IDE）│ │ └─01-C基础第14天（IDE）│ │ ├─01-C基础第十四天│ │ │ │ C基础第十四天.doc│ │ │ ││ │ │ └─IDE参考资料│ │ ││ │ ├─01笔记│ │ ││ │ ├─02代码│ │ │ ├─0223-IDE│ │ │ │ 0223-IDE.pro.user│ │ │ │ app.ico│ │ │ │ main.cpp│ │ │ │ mainwindow.cpp│ │ │ │ mainwindow.h│ │ │ │ mainwindow.ui│ │ │ ││ │ │ └─0223-passwd│ │ │ 0223-passwd.pro│ │ │ 0223-passwd.pro.user│ │ │ main.cpp│ │ │ mainwindow.cpp│ │ │ mainwindow.h│ │ │ mainwindow.ui│ │ ││ │ ├─03视频│ │ │ 01早读英语_BRD1m│ │ │ 02UI界面搭建_GEnpS│ │ │ 03文件打开_1ZDM2│ │ │ 04文件保存和编辑操作│ │ │ 05文件编译_F926V│ │ │ 06内容完善│ │ │ 07服务器入侵界面版│ │ ││ │ └─04资料│ │ dict.txt│ ││ └─01-C基础第15天（快 yi通）│ └─01-C基础第15天（快易通）│ │ 1.c│ │ hello.c│ │ http.tar.gz│ ││ ├─01-C基础第十五天│ │ │ C基础第十五天.doc│ │ │ C语言提高讲义.doc│ │ │ 第11章 综合项目-贪吃蛇.doc│ │ │ 第5章 数组与广义表.docx│ │ ││ │ ├─dict-0223│ │ │ dict-0223.pro│ │ │ dict-0223.pro.user│ │ │ main.cpp│ │ │ mainwindow.cpp│ │ │ mainwindow.h│ │ │ mainwindow.ui│ │ ││ │ └─快译通参考资料│ ││ ├─02代码│ ││ └─03视频│ 01早读英语1jLk6│ 02程序分析│ 03vs版本的快易通实现│ 04vs版本快易通完善│ 05vs版本完善│ 2017.03.19.15.14.21│ EV~2017.03.19~08.50.11│ EV~2017.03.19~15.14.42│├─02c语言提高│ ├─02-c提高01day│ │ └─C提高 day01│ │ └─课堂视频│ │ 01 课前准备│ │ 02 技术层次│ │ 03 简介│ │ 04 数据类型的概念│ │ 05 typedef用法│ │ 06 void用法│ │ 07 sizeof用法│ │ 08 变量的间接赋值│ │ 09 内存分区概念│ │ 10 上午复习│ │ 11 栈区│ │ 12 堆区│ │ 13 extern和static区别│ │ 14 const全局和局部变量区别│ │ 15 字符串常量区│ ││ ├─02-c提高02day│ │ └─C提高 day02│ │ └─课堂视频│ │ 01 昨天回顾│ │ 02 函数调用流程│ │ 03 函数的调用惯例│ │ 04 变量传递分析│ │ 05 栈的生长方向和内存存放方向│ │ 06 指针基本概念│ │ 07 指针的步长│ │ 08 指针做函数参数的输入特性│ │ 08 指针的间接赋值│ │ 09 指针做函数参数的输出特性│ │ 10 字符串拷贝│ │ 11 字符串反转│ │ 12 sprintf│ ││ ├─02-c提高03day│ │ └─C提高 day03│ │ └─课堂视频│ │ 01 calloc和realloc│ │ 02 sscanf│ │ 03 查找子串mystrstr│ │ 04 指针易错点│ │ 05 const的使用│ │ 06 二级做函数参数输出特性│ │ 08 二级指针做函数参数输入特性│ │ 09 二级指针做函数参数输入特性(2)│ │ 10 二级指针练习文件读写│ │ 11 位逻辑运算符│ │ 12 移位运算符│ ││ ├─02-c提高04day│ │ └─C提高 day04│ │ └─课堂视频│ │ 01 一维数组名│ │ 02 如何定义数组指针│ │ 03 二维数组名二位数组做函数参数│ │ 04 指针数组排序选择排序│ │ 05 结构体基本概念│ │ 06 结构体深拷贝和浅拷贝│ │ 07 结构体嵌套一级指针│ ││ ├─02-c提高05day│ │ └─C提高 day05│ │ └─课堂视频│ │ 01 以前课程问题复习│ │ 02 结构体嵌套二级指针│ │ 03 结构体偏移量│ │ 04 内存字节对齐│ │ 05 文件概念│ │ 06 文件读写注意点│ │ 07 配置文件读写(1)│ │ 08 配置文件读写(2)│ ││ ├─02-c提高06day│ │ └─C提高 day06│ │ └─课堂视频│ │ 01 函数指针概念如何定义函数指针│ │ 02 函数指针做函数参数│ │ 03 函数指针做函数参数(2)│ │ 04 链表的基本概念avi│ │ 05 静态链表│ │ 06 上午复习│ │ 07 链表的初始化遍历│ │ 08 链表插入清空│ │ 09 链表的删除销毁│ ││ └─02-c提高07day│ └─C提高 day07│ └─课堂视频│ 01 链表逆序算法│ 02 作业排序算法│ 03 预处理指令│ 04 库的基本概念│ 05 动态库和静态库流程│ 06 递归函数│ 07 面向接口编程│ 08 配置文件读写│ 09静态库和动态库│├─03数据结构│ ├─03-c提高08day_数据结构│ │ └─数据结构 day01│ │ │ 01 数据结构图概念│ │ │ 02 动态数组初始化插入遍历│ │ │ 04 动态数组分文件实现│ │ │ 05 单向链表(版本一)初始化_插入遍历│ │ │ 06 单向链表值删除位置删除大小_清空销毁│ │ │ 07 单向链表(版本二)思路0│ │ ││ │ └─课堂视频│ │ 03 动态数组删除销毁│ ││ ├─03-c提高09day数据结构│ │ └─数据结构 day02│ │ └─课堂视频│ │ 01 单向链表(版本二)初始化插入遍历│ │ 02 单向链表(版本二)删除销毁6│ │ 03 栈的概念│ │ 04 栈的顺序存储函数声明│ │ 05 栈的顺序存储函数实现│ │ 06 栈的链式存储│ │ 07 栈的应用就近匹配│ ││ └─03-c提高10day_数据结构│ └─数据结构 day03│ └─课堂视频│ 01 队列概念│ 02 链式队列实现│ 02 链式队列测试│ 04 树和二叉树的概念│ 05 二叉树的递归遍历│ 06 求二叉树的高度和叶子节点数目│ 07 二叉树的拷贝和释放│ 08 二叉树的非递归遍历│ 09 插入排序│├─04c++基础│ ├─04-c++day01│ │ └─C++ day01│ │ └─Vedio│ │ 01 课程安排│ │ 02 C++概述│ │ 03 hello World书写│ │ 04 双冒号作用域运算符│ │ 05 命名空间namespace使用avi│ │ 06 using声明和using编译指令│ │ 07 C++对C语言的增强全局变量、函数检测、类型转换、struct、bool、三目│ │ 08 const增强│ │ 09 C语言中const默认外部链接，C++默认内部链接│ │ 10 const分配内存情况│ │ 11 尽量用const代替define│ │ 12 引用的基本语法以及注意事项│ │ 13 参数的传递方式│ │ 14 引用的注意事项│ │ 15 引用的本质│ │ 16 指针的引用│ │ 17 常量引用│ ││ ├─04-c++day02│ │ └─C++ day02│ │ └─Video│ │ 01 课程回顾│ │ 02 作业案例-设计圆类│ │ 03 作业案例-设计学生类│ │ 04 内联函数的引出-宏缺陷以及内联函数和编译器处理│ │ 05 函数默认参数以及占位参数│ │ 06 函数重载的语法│ │ 07 上午课程回顾│ │ 08 函数重载的实现原理│ │ 09 extern C浅析│ │ 10 C语言下的封装和C++语言的封装区别│ │ 11 建议将成员属性设置为私有│ ││ ├─04-c++day03│ │ └─C++ day03│ │ └─Video│ │ 01 课程回顾(1)│ │ 02 面向对象设计案例-立方体案例│ │ 03 面向对象设计案例-点和圆的关系│ │ 04 对象的初始化和清理（构造和析构函数）│ │ 05 构造函数的分类及调用│ │ 06 拷贝构造函数调用时机│ │ 07 构造函数的调用规则│ │ 08 深拷贝与浅拷贝│ │ 09 初始化列表│ │ 10 类对象作为类成员的案例│ │ 11 explicit关键字作用│ │ 12 new运算符的使用│ ││ ├─04-c++day04│ │ └─C++ day04│ │ └─Video│ │ 01 前三天课程回顾│ │ 02 静态成员变量│ │ 03 静态成员函数│ │ 04 单例模式的简介│ │ 05 单例模式案例 - 主席案例│ │ 06 单例模式案例-打印机案例│ │ 07 C++对象模型初探-成员变量和成员属性分开处理│ │ 08 this指针基本使用│ │ 09 空指针访问成员函数│ │ 10 常函数与常对象│ │ 11 全局函数做友元函数│ │ 12 整个类做友元类│ │ 12 类模板的分文件编写问题以及解决│ │ 13 成员函数做友元函数│ ││ ├─04-c++day05│ │ └─C++ day05│ │ └─Video│ │ 01 课程回顾(2)│ │ 02 强化训练-数组类封装│ │ 03 加号运算符重载│ │ 04 左移运算符重载│ │ 05 前置后置递增运算符重载│ │ 06 前置后置返回值的补充│ │ 07 指针运算符重载（智能指针）│ │ 08 赋值运算符重载│ │ 09 []运算符重载│ ││ ├─04-c++day06│ │ 01 课程回顾__vTOf0│ │ 02 关系运算符重载│ │ 03 函数调用运算符重载，不要重载 与和或运算符│ │ 04 强化训练字符串封装（一）│ │ 05 强化训练字符串封装（二）│ │ 06 继承的引出│ │ 07 继承方式│ │ 08 继承中的对象模型│ │ 09 继承中的构造和析构顺序│ │ 09 继承中的构造和析构顺序（补充）│ │ 10 继承中的同名成员处理│ │ 11 继承中的静态成员处理│ │ 12 多继承的概念以及问题│ │ 13 菱形继承的问题以及解决方案│ │ 14 虚基类的内部工作原理解析│ ││ ├─04-c++day07│ │ └─C++ day07│ │ └─Video│ │ 01 Day4到Day6课程回顾│ │ 02 静态联编和动态联编│ │ 03 多态原理解析│ │ 04 多态深入剖析锻炼│ │ 05 多态案例-计算器案例│ │ 06 抽象类和纯虚函数│ │ 07 虚析构和纯虚析构函数│ │ 08 向上类型转换和向下类型转换│ │ 10 多态案例二-Pk游戏需求│ │ 11 多态案例二 pk游戏构建│ │ 12 多态案例二 游戏运行│ ││ ├─04-c++day08│ │ └─C++ day08│ │ └─Video│ │ 01 课程回顾(3)│ │ 02 函数模板基本使用│ │ 03 课堂练习-实现通用的数组排序│ │ 04 函数模板与普通函数的区别以及调用规则│ │ 05 模板机制│ │ 06 函数模板的局限性│ │ 07 类模板的基本使用│ │ 08 成员函数创建时机│ │ 09 类模板做函数的参数│ │ 10 类模板碰到继承的问题以及解决│ │ 11 类模板的类外实现成员函数│ │ 12 类模板的分文件编写问题以及解决eWmKO│ │ 13 友元碰到类模板-友元函数类内实现│ │ 13 友元碰到类模板-友元函数类外实现│ │ 14 类模板的应用-数组类的封装│ ││ └─04-c++day09│ └─C++ day09│ └─Video│ 01 课程回顾_(4)│ 02 类型转换-静态类型│ 03 类型转换-动态类型│ 04 类型转换-静态和重新解释转换│ 05 异常的基本使用│ 06 对自定义异常进行捕获│ 07 栈解旋│ 08 异常的接口声明│ 09 异常变量生命周期│ 10 异常的多态使用│ 11 使用系统标准异常│ 12 编写自己的异常类│ 13 标准输入流│ 14 标准输入流案例│ 15 标准输出流│ 16 文件的读写操作│├─05c++提高-stl│ ├─05-c++STLday10│ │ └─C++ day10-STL│ │ └─Video│ │ 01 课程回顾ObktS│ │ 02 STL基本概念│ │ 03 容器算法迭代器三大组件介绍│ │ 04 三大组件的初识│ │ 05 三大组件基本使用│ │ 06 string容器构造、赋值│ │ 07 string容器API│ │ 08 vector容器（上）│ │ 09 swap收缩空间上│ │ 10 vector容器（下）│ │ 11 deque容器│ │ 12 作业布置以及sort使用│ ││ ├─05-c++STLday11│ │ └─C++ day11-STL2│ │ └─Video│ │ 01 课程回顾__y4MLN│ │ 02 作业案例-评委打分│ │ 03 stack栈容器│ │ 04 queue队容器│ │ 05 list容器上│ │ 06 list容器下│ │ 07 list容器remove删除自定义数据类型│ │ 08 set容器上│ │ 09 set容器中│ │ 10 pair对组的创建方式│ │ 11 set容器下│ │ 12 set容器插入自定义数据类型│ │ 13 map容器│ │ 14 作业布置以及STL各个容器是使用时机│ ││ ├─05-c++STLday12│ │ 01 课程回顾(1)k1dnI│ │ 02 作业案例-员工分组│ │ 03 函数对象│ │ 04 谓词的使用│ │ 05 内建函数对象使用│ │ 06 适配器使用│ │ 07 常用遍历算法│ │ 08 常用查找算法│ │ 09 常用排序算法│ │ 10 常用拷贝和替换算法│ │ 11 常用算数生成算法│ │ 12 常用集合算法│ │ 13 作业布置│ ││ └─05-c++STLday13贪吃蛇案例│ └─C++ day13_贪吃蛇案例│ └─Video│ 01 STL综合案例-演讲比赛│ 02 贪食蛇玩法介绍以及编码分析│ 03 贪食蛇墙模块实现│ 04 贪食蛇案例-蛇模块│ 05 贪食蛇-食物模块│ 06 删除尾节点和移动封装│ 07 蛇的第一步移动│ 08 蛇移动以及bug的解决│ 09 辅助玩法、难度和分数│ 10 优化游戏│├─06qt│ ├─04-Day14_C++_QT│ │ └─Video│ │ 01 Qt课程安排│ │ 02 Qt简介以及优点、成功案例│ │ 03 Qt Creator简介│ │ 04 Main函数介绍│ │ 05 pro文件介绍│ │ 06 命名规范和常用快捷键│ │ 07 QPushButton简单使用以及窗口简单设置│ │ 08 对象树概念│ │ 09 Qt中的坐标系│ │ 10 信号槽的基本使用-点击按钮关闭窗口│ │ 11 自定义的信号和槽函数│ │ 12 自定义信号槽发送重载的问题以及解决│ │ 13 信号和槽的拓展│ │ 14 Qt4版本的信号和槽写法│ │ 15 Lambda表达式│ ││ ├─04-Day15_C++_QT│ │ └─C++ day15_Qt2│ │ └─Video│ │ 01 课程回顾_(3)lEhjb│ │ 02 QMainWindow菜单栏和工具栏│ │ 03 QMainWindow_状态栏、铆接部件、核心部件│ │ 04 资源文件│ │ 05 对话框-模态和非模态│ │ 06 QMessageBox使用│ │ 07 标准对话框-颜色对话框和文件对话框│ │ 08 登陆窗口布局│ │ 09 常用控件-按钮组│ │ 10 ListWidget控件使用│ │ 11 TreeWidgetItem使用│ │ 12 QTableWidget控件使用│ │ 13 其他常用控件│ ││ ├─04-Day16_C++QT│ │ └─Video│ │ 01 课程回顾(2)_iUWkV│ │ 02 自定义控件封装│ │ 03 QLabel中鼠标常用事件│ │ 04 定时器第一种方式│ │ 05 定时器第二种方式│ │ 06 event事件│ │ 07 事件过滤器│ │ 08 QPainter基本绘图│ │ 09 绘图高级设置│ │ 10 手动调用绘图事件│ │ 11 绘图设备│ │ 12 文件读写操作│ │ 13 文件信息│ │ 14 文本流和数据流│ ││ └─04-Day17_C++_QT│ └─Video│ 01 课程回顾│ 02 Qt案例-项目创建和对话框列表搭建│ 03 聊天窗口搭建│ 04 点击按钮弹出聊天窗口以及bug解决│ 05 简单的两人udp聊天程序│ 06 核心功能实现-群聊功能│ 07 新用户进入处理│ 08 用户离开处理│ 09 辅助功能设置│├─07mfc│ ├─07-MFC_18day│ │ 01 qt案例课程回顾│ │ 02 MFC课程安排│ │ 03 Window简单名词解析以及创建底层窗口WinMain函数介绍│ │ 04 底层实现窗口的前5步骤│ │ 05 底层窗口实现-处理窗口过程│ │ 06 利用MFC创建窗口│ │ 07 MFC中消息映射机制│ │ 08 Windows字符集介绍│ │ 09 利用向导创建MFC│ ││ ├─07-MFC_19day│ │ └─Video│ │ 01 课程回顾TUMEN│ │ 02 模态对话框创建│ │ 03 非模态对话框创建│ │ 04 StaticText静态文本使用│ │ 05 CEditCtrl控件使用│ │ 06 ComboBox下拉框使用│ │ 07 CListCtrl控件使用│ │ 08 CTreeCtrl 树控件使用│ │ 09 TabCtrl标签控件使用│ ││ └─07-MFC_20day│ └─Video│ 01 项目简介以及项目配置│ 02 静态拆分窗口│ 03 树视图功能实现│ 04 个人信息界面布局│ 05 个人信息的界面挂载│ 06 个人信息功能实现│ 07 销售管理界面│ 10 菜单栏添加│ 8 添加商品│ 9 添加新商品│├─08linux│ └─8linux│ ├─08_Linux命令基础│ │ ├─08-linux-day01(常用命令)│ │ │ └─01-linux-day01(常用命令)│ │ │ └─3-视频│ │ │ 01_linux历史│ │ │ 02_linux学习内容概括│ │ │ 03_ls命令和相对路径绝对路径│ │ │ 04_目录相关操作│ │ │ 05_文件相关操作命令│ │ │ 06_文件内容查看│ │ │ 07_统计相关信息│ │ │ 08_文件权限位和软硬连接│ │ │ 09_删除软硬连接│ │ │ 10_修改文件的用户和组│ │ │ 11_中午复习│ │ │ 12_find_grep_xargs│ │ │ 13_grep补充│ │ │ 14_zip与tar压缩文件│ │ │ 15_rar压缩│ │ │ 16_虚拟机网络配置│ │ │ 17_软件安装和卸载│ │ │ 18_其他常用命令│ │ │ 19_补码和关机│ │ │ 20_总结│ │ ││ │ ├─08-linux-day02(vim-gcc-library)│ │ │ └─02-linux-day02(vim-gcc-library)│ │ │ └─3-视频│ │ │ 01_前一天回顾│ │ │ 02_vim光标的移动│ │ │ 03_vim删除内容│ │ │ 04_vim复制粘贴与可视模式│ │ │ 05_vim查找格式调整查看man文档│ │ │ 06_vim从命令模式到编辑模式│ │ │ 07_vim末行查找替换与保存退出│ │ │ 08_vim分屏模式│ │ │ 09_vim的设置│ │ │ 10_gcc编译流程│ │ │ 11_上午内容回顾│ │ │ 12_gcc流程和相关参数│ │ │ 13_gcc编译参数2│ │ │ 14_gcc补充说明│ │ │ 15_静态库的制作和使用│ │ │ 16_动态库的制作│ │ │ 17_动态库的使用│ │ │ 18_静态库与动态库的总结│ │ │ 19_总结│ │ ││ │ ├─08-linux-day03(makefile-gdb-IO)│ │ │ └─03-linux-day03(makefile-gdb-IO)│ │ │ └─3-视频│ │ │ 01_前一天复习│ │ │ 02_ftp工具介绍│ │ │ 03_今日内容│ │ │ 04_makefile编写1│ │ │ 05_makefile编写2│ │ │ 06_makefile编写3│ │ │ 07_makefile补充│ │ │ 08_上午回顾│ │ │ 09_gdb调试1│ │ │ 10_gdb调试2_(可能是加密过的文件，请核实)│ │ │ 11_gdb调试core文件│ │ │ 12_系统api与库函数的关系│ │ │ 13_open_close函数介绍│ │ │ 14_open_close实现touch│ │ │ 15_read-write│ │ │ 16_lseek实现文件读写位置改变│ │ │ 17_lseek计算文件大小│ │ │ 18_lseek拓展文件│ │ │ 19_阻塞和非阻塞相关的概念│ │ │ 20_fcntl函数设置非阻塞│ │ │ 21_总结和作业│ │ ││ │ └─08-linux-day04(stat-readdir-dup2)│ │ └─04-linux-day04(stat-readdir-dup2)│ │ └─3-视频│ │ 01_复习前一天内容│ │ 02_学习目标和虚拟地址空间│ │ 03_打开最大文件数量│ │ 04_stat函数介绍│ │ 05_stat函数介绍2与stat命令│ │ 06_实现ls-l命令1│ │ 07_实现ls-l命令2│ │ 08_stat与lstat的区别│ │ 09_access与truncate│ │ 10_readlink_unlink│ │ 11_上午回顾│ │ 12_unlink补充│ │ 13_chown与rename│ │ 14_chdir_getcwd切换目录和获得工作路径│ │ 15_mkdir创建目录│ │ 16_读目录相关函数介绍│ │ 17_递归子目录统计普通文件个数│ │ 18_errno说明│ │ 19_dup2和dup说明│ │ 20_dup2和dup的使用│ │ 21_总结和作业_wn7j8│ ││ ├─09_Linux系统课程│ │ ├─09-linux-day05(进程控制)│ │ │ └─05-linux-day05(进程控制)│ │ │ └─3-视频│ │ │ 01_复习│ │ │ 02_学习目标│ │ │ 03_进程和程序│ │ │ 04_单道和多道程序设计│ │ │ 05_进程的状态转化│ │ │ 06_MMU的作用│ │ │ 07_PCB的概念│ │ │ 08_获取环境变量│ │ │ 09_进程控制函数fork│ │ │ 10_fork创建子进程│ │ │ 11_进程控制的命令│ │ │ 12_创建n个子进程│ │ │ 13_循环创建n个子进程控制顺序│ │ │ 14_上午回顾│ │ │ 15_父子进程共享的内容│ │ │ 16_父子进程不共享全局变量│ │ │ 17_execlp函数介绍│ │ │ 18_exec函数规律│ │ │ 19_execl实现自定义程序│ │ │ 20_孤儿进程与僵尸进程│ │ │ 21_wait函数简单使用和说明│ │ │ 22_wait回收并且查看死亡原因│ │ │ 23_waitpid回收子进程│ │ │ 24_用wait回收多个子进程│ │ │ 25_waitpid回收多个子进程│ │ │ 26_总结和作业│ │ ││ │ ├─09-linux-day06(进程间通信)│ │ │ └─06-linux-day06(进程间通信)│ │ │ │ 06-linux-day06(进程间通信).zip│ │ │ ││ │ │ └─3-视频│ │ │ 01_内容回顾│ │ │ 02_学习目标和ipc概念│ │ │ 03_管道的概念│ │ │ 04_管道通信举例1│ │ │ 05_父子进程实现ps-grep命令│ │ │ 06_ps_grep命令实现问题解决│ │ │ 07_管道的读写行为│ │ │ 08_管道大小和优劣│ │ │ 10_fifo实现通信写端│ │ │ 11_fifo使用注意事项│ │ │ 12_上午内容回顾_(可能是加密过的文件，请核实)│ │ │ 13_mmap映射开始│ │ │ 14_mmap注意事项1│ │ │ 15_mmap注意事项2│ │ │ 16_mmap实现父子进程通信│ │ │ 17_匿名映射│ │ │ 18_mmap实现无血缘关系进程通信│ │ │ 19_mmap_MAP_SHARED再次说明│ │ │ 20_总结和作业│ │ │ 21_信号的概念│ │ ││ │ ├─09-linux-day07(信号)│ │ │ └─07-linux-day07(信号)│ │ │ └─3-视频│ │ │ 01_内容复习│ │ │ 02_作业说明│ │ │ 03_信号的回顾│ │ │ 04_学习目标│ │ │ 05_阻塞信号集未决信号集信号产生│ │ │ 06_raise和abort│ │ │ 07_alarm发送信号│ │ │ 08_setitimer使用│ │ │ 09_setitimer实现alarm前│ │ │ 10_setitimer实现alarm后│ │ │ 11_1秒数数│ │ │ 12_上午内容回顾│ │ │ 13_信号集的函数│ │ │ 14_打印未决信号集│ │ │ 15_sigaction捕捉setitimer产生信号│ │ │ 16_sigaction特性演示│ │ │ 17_信号的处理流程│ │ │ 18_利用SIGCHLD回收子进程│ │ │ 19_SIGCHLD回收注意事项│ │ │ 20_总结和作业A5Tw2│ │ ││ │ ├─09-linux-day08(守护进程-线程)│ │ │ └─08-linux-day08（守护进程-线程）│ │ │ └─3-视频│ │ │ 01内容回顾fcTWu│ │ │ 02守护进程相关的概念│ │ │ 03_守护进程创建│ │ │ 04_守护进程扩展了解│ │ │ 05_线程有关的概念│ │ │ 06_线程的优点和缺点│ │ │ 07_创建一个线程│ │ │ 08_线程的退出│ │ │ 09_线程的回收│ │ │ 10_上午内容的回顾│ │ │ 11_杀死线程│ │ │ 12_线程分离│ │ │ 13_线程属性设置分离│ │ │ 14_线程注意事项│ │ │ 15_总结和作业│ │ │ 16_线程同步的概念│ │ │ 17_mutex相关的函数│ │ ││ │ └─09-linux-day09（线程同步）│ │ └─09-linux-day09（线程同步）│ │ └─3-视频│ │ 01_内容回顾qu1zH│ │ 02学习目标qKSuX│ │ 03互斥量的使用│ │ 04_死锁│ │ 05_读写锁│ │ 06_条件变量介绍和生产者和消费者模型│ │ 07_上午内容回顾│ │ 08_条件变量生产者消费者模型实现│ │ 09_条件变量生产者和消费者模型演示│ │ 10_信号量的概念和函数│ │ 11_信号量实现生产者和消费者分析│ │ 12_信号量实现生产者和消费者│ │ 13_文件锁单开进程│ │ 14_哲学家就餐模型分析│ │ 15_总结│ ││ ├─10_linux高并发网络编程开发│ │ ├─10-Linux系统编程-第10天（网络编程基础-socket）│ │ │ │ 10-Linux系统编程-第10天（网络编程基础-socket）.zip│ │ │ ││ │ │ └─10-Linux系统编程-第10天（网络编程基础-socket）│ │ │ │ 10-Linux系统编程-第10天（网络编程基础-socket）.zip│ │ │ ││ │ │ └─3-视频│ │ │ 01-知识点概述│ │ │ 02-网络开发两种设计模式│ │ │ 03-网络模型分层│ │ │ 04-以太网帧协议│ │ │ 05-IP协议│ │ │ 06-udp协议│ │ │ 07-tcp协议│ │ │ 08-tcp-ip四层模型协议封装│ │ │ 09-udp和tcp讲解│ │ │ 10-什么是套接字│ │ │ 11-套接字内存模型│ │ │ 12-知识点复习│ │ │ 13-大端和小端存储.mkv│ │ │ 14-大小端转换函数.mkv│ │ ││ │ ├─10-Linux系统编程-第11天（tcp三次握手-并发）│ │ │ │ 10-Linux系统编程-第11天（tcp三次握手-并发）.zip│ │ │ ││ │ │ └─10-Linux系统编程-第11天（tcp三次握手-并发）│ │ │ │ 10-Linux系统编程-第11天（tcp三次握手-并发）.zip│ │ │ ││ │ │ └─3-视频│ │ │ 01-学习目标│ │ │ 02-知识点回顾│ │ │ 03-tcp客户端代码实现│ │ │ 04-socket函数封装│ │ │ 05-tcp三次握手│ │ │ 06-tcp的数据传输过程│ │ │ 07-四次挥手│ │ │ 08-滑动窗口│ │ │ 09-多进程并发服务器分析│ │ │ 10-多进程并发服务器伪代码│ │ │ 11-多进程并发服务器代码实现│ │ │ 12-多线程并发服务器实现思路│ │ │ 13-多线程版客户端代码实现│ │ ││ │ ├─10-Linux系统编程-第12天（tcp状态转换-select-poll）│ │ │ │ 10-Linux系统编程-第12天（tcp状态转换-select-poll）.zip│ │ │ ││ │ │ ├─05-Linux系统编程-第12天（tcp状态转换-select-poll）│ │ │ │ │ 05-Linux系统编程-第12天（tcp状态转换-select-poll）.zip│ │ │ │ ││ │ │ │ └─3-视频│ │ │ │ 01-知识点概述│ │ │ │ 02-三次握手四次挥手复习│ │ │ │ 03-多进程多线程并发复习│ │ │ │ 04-recv和send函数│ │ │ │ 05-tcp状态转换│ │ │ │ 06-2msl等待时长│ │ │ │ 07-半关闭│ │ │ │ 08-netstat命令│ │ │ │ 09-端口复用设置│ │ │ │ 10-IO多路转接讲解│ │ │ │ 11-内核大致是如何实现IO转接的│ │ │ │ 12-select的参数和返回值│ │ │ │ 13-复习│ │ │ │ 14-select工作过程│ │ │ │ 15-select伪代码│ │ │ │ 16-select代码实现│ │ │ │ 17-poll函数介绍│ │ │ │ 18-poll实现IO转接代码分析│ │ │ ││ │ │ └─BeyondCompare-v4.07│ │ │ BC4Key.txt│ │ │ BCompare-4.0.7.19761.exe│ │ ││ │ ├─10-Linux系统编程-第13天（epoll-udp）│ │ │ │ 10-Linux系统编程-第13天（epoll-udp）.zip│ │ │ ││ │ │ └─05-Linux系统编程-第13天（epoll-udp）│ │ │ │ 05-Linux系统编程-第13天（epoll-udp）.zip│ │ │ ││ │ │ └─3-视频│ │ │ 01-知识点概述_25JIU│ │ │ 02-通过gdb定位段错误的位置│ │ │ 03-tcp状态转换复习│ │ │ 04-select复习│ │ │ 05-epoll相关的函数介绍│ │ │ 06-epoll工作流程│ │ │ 08-epoll模型代码实现│ │ │ 09-epoll复习│ │ │ 10-epoll水平触发模式│ │ │ 11-边沿触发模式│ │ │ 12-边沿非阻塞模式│ │ │ 13-文件描述符突破1024│ │ │ 14-udp通信流程│ │ │ 15-udp服务器端代码实现│ │ │ 16-udp客户端代码实现│ │ ││ │ ├─10-Linux系统编程-第14天（广播-组播-本地套接字）│ │ │ │ 10-Linux系统编程-第14天（广播-组播-本地套接字）.zip│ │ │ ││ │ │ └─05-Linux系统编程-第14天（广播-组播-本地套接字）│ │ │ │ 05-Linux系统编程-第14天（广播-组播-本地套接字）.zip│ │ │ ││ │ │ └─3-视频│ │ │ 01-知识点概述_sQAeH│ │ │ 02-epoll复习│ │ │ 03-udp通信流程复习│ │ │ 04-tcp udp使用场景│ │ │ 05-广播通信流程│ │ │ 06-广播服务器代码实现│ │ │ 07-广播客户端代码实现│ │ │ 08-广播通信流程总结│ │ │ 09-广播通信流程│ │ │ 10-组播服务器代码实现│ │ │ 11-组播客户端代码实现│ │ │ 12-复习│ │ │ 13-本地套接字通信流程│ │ │ 14-本地套接字server实现│ │ │ 15-本地套接字客户端实现│ │ │ 16-心跳包│ │ │ 17-epoll反应堆模型main函数│ │ │ 18-epoll反应堆模型监听套接字初始函数│ │ │ 19-epoll反应堆模型acceptconn函数│ │ ││ │ ├─10-Linux系统编程-第15天（libevent）│ │ │ │ 10-Linux系统编程-第15天（libevent）.zip│ │ │ ││ │ │ └─05-Linux系统编程-第15天（libevent）│ │ │ │ 05-Linux系统编程-第15天（libevent）.zip│ │ │ ││ │ │ └─3-视频│ │ │ 01-知识点介绍│ │ │ 02-epoll反应堆模型recvdata函数│ │ │ 03-epoll反应堆模型事件操作流程│ │ │ 04-epoll反应堆模型-senddata函数│ │ │ 05-epoll反应堆模型节点事件检测│ │ │ 06-libevent的安装和测试│ │ │ 07-解决动态库找不到的问题│ │ │ 08-event_base讲解│ │ │ 09_event_base相关的小函数│ │ │ 10-event事件的创建│ │ │ 11-消息循环│ │ │ 12-复习_pD6T4│ │ │ 13-libevent内部事件的状态转换│ │ │ 14-使用event读管道│ │ │ 15-使用event写管道│ │ │ 16-bufferevent介绍│ │ │ 17-bufferevent的创建和回调函数的设置│ │ │ 18-socket通信客户端连接服务器时用到的函数│ │ │ 19-bufferevent读写缓冲区是否可用的设置│ │ │ 20-evconnlistener_new_bind函数│ │ │ 21-链接监听器对应的小函数│ │ │ 22-bufferevent实现服务器端代码│ │ ││ │ └─10-Linux系统编程-第16天（xml json）│ │ │ 10-Linux系统编程-第16天（xml json）.zip│ │ ││ │ └─10-Linux系统编程-第16天（xml json）│ │ │ 10-Linux系统编程-第16天（xml json）.zip│ │ ││ │ └─3-视频│ │ 01-知识点概述_YtWDU│ │ 02-libevent整体工作流程回顾│ │ 03-libevent socket客户端代码实现│ │ 03-libevent socket服务器复习│ │ 05_bug│ │ 06-xml文件格式│ │ 07-xml示例文件│ │ 08-xml文件的设计│ │ 09-mxml安装和配置│ │ 10-mxml生成文件函数介绍│ │ 11-使用mxml api生成xml文件│ │ 12-mxml获取文件数据api│ │ 13-mxml格式文件解析│ │ 14-json文件格式│ │ 15-json格式示例文件│ │ 16-cjon介绍│ │ 17-cjson api创建json文件│ │ 18-cjson解析api│ ││ └─11_linux高并发web服务器开发│ ├─11_服务器开发-第01天（web服务器 - 1）│ │ │ 11_服务器开发-第01天（web服务器 - 1）.zip│ │ ││ │ └─01-服务器开发-第01天（web服务器 - 1）│ │ │ 01-服务器开发-第01天（web服务器 - 1）.zip│ │ ││ │ └─3-视频│ │ 01-知识点概述ijAcY│ │ 02-复习│ │ 03-cjson解析json文件代码│ │ 04-html介绍│ │ 05-标题和段落相关的标签│ │ 06-列表标签│ │ 07-图片标签│ │ 08-超链接标签│ │ 09-给图片设置超链接│ │ 10-table标签的使用│ │ 11-http协议请求消息│ │ 12-http请求一个url生成的请求协议分析│ │ 13-http响应消息│ │ 14-web服务器模型实现思路│ ││ ├─11服务器开发-第02天（web服务器 - 2）│ │ │ 11_服务器开发-第02天（web服务器 - 2）.zip│ │ ││ │ └─02-服务器开发-第03天（web服务器 - 3）│ │ │ 02-服务器开发-第03天（web服务器 - 3）.zip│ │ ││ │ └─3-视频│ │ 01-sourceInsight使用│ │ 02-知识点概述│ │ 03-http协议复习│ │ 04-epoll 服务器epoll模型代码│ │ 05-epoll模型接受连接请求函数│ │ 05-getline函数│ │ 06-do_read函数│ │ 07-正则表达式入门│ │ 08-sscanf使用正则表达式格式化字符串│ │ 09-http_resquest函数│ │ 10-发送http响应头函数│ │ 11-发送普通文件函数实现│ │ 12-使用readdir读目录│ │ 13-scandir读目录│ │ 14-处理http协议需要编码和解码的原因│ │ 15-编解码函数介绍│ │ 16-程序测试│ ││ └─11_服务器开发-第03天（web服务器 - 3）│ │ 11_服务器开发-第03天（web服务器 - 3）.zip│ ││ └─03-服务器开发-第03天（web服务器 - 3）│ │ 03-服务器开发-第03天（web服务器 - 3）.zip│ ││ └─3-视频│ 01-知识点概述zTkN2│ 02-strftime│ 03-libevent实现httpserver│ 04-线程池原理│ 05-线程池结构体│ 06-如何使用线程池api│ 07-初始化线程池的函数│ 08-干活的线程的回调函数│ 09-管理者线程回调函数│├─09数据库│ ├─09-数据库编程day01(oracle sql)│ │ 01安装配置│ │ 02_linux-oracle服务器启动│ │ 02_oracle的体系结构│ │ 03_oracle相关的概念│ │ 05_登陆和基本设置│ │ 07_条件过滤1│ │ 08_条件过滤2逻辑运算符│ │ 09-数据库编程day0104_oracle的安装│ │ 09-数据库编程day0106_基本查询│ │ 09-数据库编程day0110_条件过滤3集合中模糊匹配│ │ 09上午回顾│ │ 11_排序│ │ 12_字符函数│ │ 13_数值函数│ │ 14_转换函数│ │ 15_日期函数│ │ 16_条件表达式│ │ 17_分组函数│ │ 18_分组数据│ │ 19_在redhat创建hr数据库用户│ ││ ├─09-数据库编程day02(oracle sql)│ │ └─3-视频│ │ 01_前一天复习│ │ 02_多表查询的理论基础│ │ 03_等值连接不等值连接│ │ 04外连接│ │ 05_自连接│ │ 06_子查询1│ │ 07_子查询2│ │ 08_子查询3│ │ 09_plsqldevloper介绍│ │ 10_上午复习│ │ 11_集合运算│ │ 12_新增数据│ │ 13_修改与删除数据│ │ 14_delete与truncate│ │ 15_事务相关的概念│ │ 16_事务控制│ │ 17_练习提示│ │ 18_练习答案说明│ ││ ├─09-数据库编程day03(oracle mysql sql)│ │ └─3-视频│ │ 01_前2天复习│ │ 02_表的创建和管理│ │ 03_表的约束│ │ 04_序列的使用│ │ 05_视图│ │ 06_同义词│ │ 07_索引│ │ 08_上午内容回顾│ │ 09_客户端创建解决方案│ │ 10_mysql基础│ │ 11_mysql组合拳保证服务正常│ │ 12_mysql库的操作│ │ 13_mysql表的操作│ │ 14_mysql数据的操作│ │ 15_mysql组函数相关│ │ 16_mysql日期函数数字函数字符函数│ │ 17_mysql转换函数│ │ 18_mysql多表查询准备│ │ 19_mysql内连接│ │ 20_mysql多表查询│ │ 21_mysql补充│ ││ ├─09-数据库编程day04(mysql api)│ │ └─3-视频│ │ 01_复习│ │ 02_mysql相关约束│ │ 03_中文乱码问题│ │ 04_适应开发环境│ │ 05_通过api连接到数据库│ │ 06_通过api增加数据│ │ 07_通过api实现查询分析│ │ 08_实现查询的功能│ │ 09_上午回顾QHv2O│ │ 10_查询改进│ │ 11_客户端实现│ │ 12_字符集的问题│ │ 13_字符集问题处理│ │ 14_预处理的流程│ │ 15_预处理的内存映射│ │ 16_mysql通过api处理事务│ │ 17_mongodb数据库的安装│ │ 18_mongodbc++驱动安装│ │ 19_课后作业说明│ ││ ├─09-数据库编程day05(mongodb json)│ │ 01_复习前一天│ │ 02_作业1│ │ 03_作业2│ │ 04_mongo安装复习│ │ 05_mongodb的简介│ │ 06_mongodb库的操作│ │ 07_新增文档│ │ 08_查看文档1│ │ 09_查看文档2│ │ 10_更新文档│ │ 11_删除文档│ │ 12_上午复习│ │ 13_mongo的索引│ │ 14_聚合函数│ │ 15_副本集实验│ │ 16_vs配置方法│ │ 17_通过api连接到mongodb│ │ 18_通过api删除文档│ │ 19_通过api新增文档│ ││ └─09-数据库编程day06(案例开发)│ └─3-视频│ 01_前一天内容复习│ 02_通过api修改数据和查询分析│ 03_通过api查询文档│ 04_通过api查询文档内容解析异常捕捉│ 05_案例需求分析模型设计│ 06搭建框架│ 07_mysql端登陆实现│ 08_sql注入问题解决│ 09_查看功能实现│ 10_mysql侧实现上传功能│ 11_上传文件mongo侧实现│ 12_mysql与mongo类的调用│ 13_上传测试成功│ 14_下载功能实现│ 15_总结│├─10安全传输平台项目│ ├─09-安全传输平台项目-第01天（简介-需求-方案-演示-部署）│ │ └─3-视频│ │ 01-项目总述│ │ 02-对称加密和非对称加密│ │ 03-项目需求分析│ │ 04-项目开发流程注意事项│ │ 05-项目模块分工│ │ 06-复习│ │ 07-数据库配置-防火墙关闭│ │ 08-数据库-启动│ │ 09-数据库TNS服务│ │ 10-数据库-客户端安装使用│ │ 11-数据库-项目建表脚本│ │ 12-创建用户管理项目理念│ │ 13-创建用户管理项目│ │ 14-log日志说明│ │ 15-配置管理终端配置简述│ ││ ├─09-安全传输平台项目-第02天（keymngserver重构-硬件扩展）│ │ └─3-视频│ │ 01-上一次课程复习│ │ 02-上一次课程复习-作业点评│ │ 03-C++类对象模型初探│ │ 04-服务器框架复习上│ │ 05-服务器框架复习上和编程思路│ │ 06-keymngserver设计与实现-hello和dbapi类│ │ 07-keymngserver设计与实现-keymngserverapp类│ │ 08-keymngserver设计与实现-keymngserverop类│ │ 09-keymngserver设计与实现-keymngserver集成keymngserverop│ │ 10-keymngserver设计与实现-keymngserver_init流程和run流程分析│ │ 11-keymngserver设计与实现-exit实现和业务流调试│ │ 12-keymngserver设计与实现-run实现│ │ 13-keymngserver设计与实现-下午课程│ │ 14-中午课程复习│ │ 15-keymngsever设计与实现-面向抽象类编程-编码│ │ 16-keymngsever设计与实现-面向抽象类编程-测试│ │ 17-设备扩展-管理功能了解│ │ 18-设备扩展-设备编程│ │ 19-设备扩展-设备工作原理│ ││ ├─09-安全传输平台项目-第02天（统一报文编解码一教师结构体编码）│ │ └─3-视频│ │ 01-复习│ │ 02-常见基础报文类型│ │ 03-BER报文编解码│ │ 04-指针充当函数返回值│ │ 05-统一报文编解码函数接口│ │ 06-教师结构体编码预览│ │ 07-教师结构体编码实现│ │ 08-中午复习│ │ 09-解码教师结构体分析│ │ 10-教师结构体解码实现│ │ 11-内存释放│ │ 12-统一报文编解码函数接口│ │ 13-报文接口封装注意事项│ ││ ├─09-安全传输平台项目-第03天（统一报文-动态库制作-统一通信组件-函数接口）│ │ └─3-视频│ │ 02-第一次考试说明│ │ 03-教师结构体编码解码封装│ │ 04-wind下制作动态库原理│ │ 05-wind动态库制作│ │ 06-库使用问题总结│ │ 07-LInux动态库制作理论│ │ 08-linux下动态库制作│ │ 09-中午复习│ │ 10-makefile复习│ │ 11-makefile项目目录管理│ │ 12-统一通信组件-客户端服务器API│ │ 13-统一通信组件-服务器实现│ │ day0301-复习│ ││ ├─09-安全传输平台项目-第04天（统一通信组件-统一共享内存组件）│ │ └─3-视频│ │ 01-复习Fc6nP│ │ 02-服务器回顾│ │ 03-客户端连接服务器│ │ 04-客户端连接池连接服务器│ │ 05-线程传参现象展示│ │ 06-线程传参内存冗余法│ │ 07-中午复习│ │ 08-常见IPC│ │ 09-简单内存模型分析│ │ 10-共享内存操作函数-shmget│ │ 11-共享内存操作函数-shmat_dt│ │ 12-共享内存操作函数-shmctl│ │ 13-Linux内核管理共享内存方法。│ │ 14-共享内存操作函数接口│ │ 15-客户端服务器密钥协商预说明│ ││ ├─09-安全传输平台项目-第05天（密钥协商服务器-密钥协商客户端）│ │ └─3-视频│ │ 01-复习QY2TI│ │ 02-密钥协商-物理组件集成│ │ 03-密钥协商-日志的使用│ │ 04-密钥协商客户端-模块划分│ │ 05-密钥协商客户端-框架实现│ │ 06-密钥协商客户端-Agree函数框架│ │ 07-密钥协商客户端-Agree函数实现│ │ 08-中午复习9Hrlz│ │ 09-密钥协商客户端-Agree函数内存释放│ │ 10-密钥协商服务器-框架梳理│ │ 11-密钥协商服务器-业务逻辑实现│ │ 12-密钥协商服务器-Agree功能实现│ │ 13-总结│ ││ ├─09-安全传输平台项目-第06天（密钥协商共享内存-守护进程-脚本）│ │ └─3-视频│ │ 02-共享内存操作函数接口设计│ │ 03-共享内存操作函数实现领读│ │ 04-生成密钥-组织密钥结构体信息│ │ 05-客户端写密钥信息到共享内存│ │ 06-服务器内存释放│ │ 07-共享内存补充说明│ │ 08-中午回顾│ │ 09-服务器守护进程创建│ │ 10-守护进程管理脚本│ │ 11-借助信号管理守护进程│ │ 12-密钥校验流程分析│ │ day6-01-复习│ ││ ├─09-安全传输平台项目-第07天（密钥协商设计与实现–数据库操作）│ │ └─3-视频│ │ 02-数据库-启动回顾│ │ 03-数据库-sql语句回顾│ │ 04-数据库-事务回顾│ │ 05-数据库-函数接口设计1│ │ 06-数据库-显示中文问题│ │ 07-数据库-游标说明│ │ 08-数据库-函数接口设计2│ │ 09-数据库-proc说明│ │ 10-数据库-访问API│ │ 11-中午复习│ │ 12-数据库-非查询语句API使用│ │ 13-数据库-错误调试│ │ 14-数据库-查询语句API│ │ 15-数据库-行存储内存模型打造│ │ 16-数据库-操作接口│ │ 17-数据库-base64编码和函数注意事项│ │ day701-复习│ ││ ├─09-安全传输平台项目-第08天（密钥协商设计与实现–存数据库-mfc项目创建）│ │ └─3-视频│ │ 01-复习_0│ │ 01-复习_1│ │ 02-密钥协商存数据库│ │ 03-表外键约束导致的插入时间错误│ │ 04-密钥注销流程分析│ │ 05-4大基础组件源码│ │ 06-数据库连接池错误说明│ │ 07-午后回顾│ │ 08-配置odbc驱动│ │ 09-odbc驱动错误说明│ │ 10-界面框架思想│ │ 11-mfc空项目创建│ │ 12-处理源码中cur图标对应错误│ │ 13-添加消息宏定义│ ││ ├─09-安全传输平台项目-第09天（配置管理终端-框架搭建-初始化）│ │ │ 01-复习数据库写入│ │ ││ │ └─3-视频│ │ 02-复习框架导入│ │ 03-重画背景onDrow│ │ 04-界面切换-CCfgView│ │ 05-界面切换-网点信息管理界面NetInfo│ │ 06-多态知识回顾│ │ 07-多态分析和开源源码走读│ │ 08-午后回顾│ │ 09-管理终端功能简析│ │ 10-初始化-获取配置文件路径│ │ 11-创建对话框│ │ 12-弹窗供用户输入信息│ │ 13-将用户录入数据保存ini文件│ │ 14-全局变量赋值及取消按钮│ │ 15-测试连接数据库│ │ 16-总结│ ││ ├─09-安全传输平台项目-第10天（配置管理终端-读写数据库）│ │ │ 01-复习gcxUA│ │ ││ │ └─3-视频│ │ 02-连接数据库│ │ 03-管理终端操作数据库原理│ │ 04-服务器配置参数管理界面布局│ │ 05-记录类的概念│ │ 06-生成记录类│ │ 07-记录类常用API│ │ 08-借助记录类读取数据库│ │ 09-记录类查询ip-port-maxnode│ │ 10-午后回顾│ │ 11-写数据库实现思路│ │ 12-写数据库实现│ │ 13-踩内存错误│ │ 14-网点信息管理-初始化listControl控件│ │ 15-网点信息管理-创建网点│ │ 16-网点信息管理-查询网点信息│ │ 17-网点信息管理-删除网点和修改网点介绍│ ││ └─09-安全传输平台项目-第11天（客户端代码移植-项目模块总结）│ └─3-视频│ 02-网点信息管理-复习│ 03-图形客户端-密钥协商组件分析│ 04-图形客户端-物理组件集成│ 05-图形客户端-Linux源码对接错误调试│ 06-图形客户端-系统初始化│ 07-图形客户端-删除控件对应函数│ 08-图形客户端-密钥协商│ 09-图形客户端-密钥协商内存释放错误说明│ 10-复习│ 11-接口设计│ 12-文件加密原理│ 13-文件加密函数源码│ 14-数字证书│ day1101-复习│├─11安全传输平台扩展│ ├─09-安全传输平台项目扩展-第01天（C复习-C++复习-keymngclient重构）│ │ │ 09-安全传输平台项目扩展-第01天（C复习-C++复习-keymngclient重构）.zip│ │ ││ │ └─VOIDE│ │ 01-课程安排│ │ 02-C语言知识体系复习-两个模型-指针做函数搭建框架│ │ 03-C语言知识体系复习-两个模型-指针做函数api实现│ │ 04-C语言知识体系复习-模拟函数调用入栈出栈内存模型│ │ 05-C语言知识体系复习-间接赋值的重要性和成立三个条件│ │ 06-C++语言知识体系复习-多态理解1│ │ 07-C++语言知识体系复习-多态理解2│ │ 08-C++语言知识体系复习-C和C++横向比较│ │ 09-C语言知识体系复习-回调函数│ │ 10-C++面向抽象类编程思想回顾│ │ 11-项目需求和方案│ │ 12-中午课程复习│ │ 13-C++类对象之间的关系-依赖和关联│ │ 14-密钥协商客户端业务流复习│ │ 15-keymngclient设计与实现-思路│ │ 16-keymngclient设计与实现-keymngclient的hello│ │ 17-keymngclient设计与实现-LogHelper│ │ 18-keymngclient设计与实现-myipc类│ │ 19-keymngclient设计与实现-KeyMng_ShmOp类│ │ 20-keymngclient设计与实现-应用程序框架类和业务流类设计思想│ │ 21-keymngclient设计与实现-keymngclientapp│ │ 22-keymngclient设计与实现-keymngclientop│ │ 23-keymngclient设计与实现-初始化流程编写│ │ 24-keymngclient设计与实现-初始化流程调试│ │ 25-keymngclient设计与实现-密钥协商编写和调试│ │ 26-作业│ ││ ├─09-安全传输平台项目扩展-第02天（keymngserver重构-硬件扩展）│ │ └─09-安全传输平台项目扩展-第02天（keymngserver重构-硬件扩展）│ │ │ 09-安全传输平台项目扩展-第02天（keymngserver重构-硬件扩展）.zip│ │ ││ │ └─3-视频│ │ 01-上一次课程复习O1GCW│ │ 02-上一次课程复习-作业点评3vQMI│ │ 03-C++类对象模型初探mxYFW.avi│ │ 04-服务器框架复习上3Ox7s│ │ 05-服务器框架复习上和编程思路umYBy│ │ 06-keymngserver设计与实现-hello和dbapi类9XNHo│ │ 07-keymngserver设计与实现-keymngserverapp类g0ci1│ │ 08-keymngserver设计与实现-keymngserverop类tZAXs│ │ 09-keymngserver设计与实现-keymngserver集成keymngserverop__FGHjo│ │ 10-keymngserver设计与实现-keymngserver_init流程和run流程分析O9Qri│ │ 11-keymngserver设计与实现-exit实现和业务流调试Nx7BF│ │ 12-keymngserver设计与实现-run实现rdyIA│ │ 13-keymngserver设计与实现-下午课程sc86R│ │ 14-中午课程复习D2tYd│ │ 15-keymngsever设计与实现-面向抽象类编程-编码muYQ9│ │ 16-keymngsever设计与实现-面向抽象类编程-测试gFQU2│ │ 17-设备扩展-管理功能了解NEfFA│ │ 18-设备扩展-设备编程m38vM│ │ 19-设备扩展-设备工作原理lw3HT│ ││ └─09-安全传输平台项目扩展-第03天（项目延展-项目演说）│ └─09-安全传输平台项目扩展-第03天（项目延展-项目演说）│ │ 09-安全传输平台项目扩展-第03天（项目延展-项目演说）.zip│ ││ └─3-视频│ 02-项目外延思考│ 03-项目外延思考2│ 22222.avi│ day0301-复习IbZLK│ one.avi│ 余毕华.avi│ 刘涛.avi│ 张玉成-王如意.avi│ 景路遥.avi│ 李和鉴.avi│ 杭兴文.avi│ 欧义桥.avi│├─12云pan项目│ ├─传智云pan项目- 01天│ │ └─03-视频│ │ 01-课程安排CHiyO│ │ 01天08-fastDFS安装│ │ 02-项目整体架构│ │ 03-web服务器│ │ 04-分布式文件系统│ │ 05-数据库和文件系统│ │ 06-fastdfs三个角色和他们之间的关系│ │ 07-fastDFS集群│ │ 09-追踪器配置文件修改│ │ 10-存储节点配置文件│ │ 11-客户端配置文件配置和fastDFS启动+测试│ │ 12-fastDFS安装和配置复习│ │ 13-fastdfs进程启动复习│ │ 14-fastDFS文件的上传和下载流程│ │ 15-解决动态库找不到的问题│ │ 16-fastDFS上传操作源码分析│ │ 17-使用进程的方式实现文件的上传操作│ │ 18-log日志文件的使用│ ││ ├─传智云pan项目- 02天│ │ └─03-视频│ │ 01-知识点概述__FlRbr│ │ 02-ubuntu下设置静态IP│ │ 03-复习│ │ 04-关于log日志文件中的宏定义│ │ 06-makefile的使用│ │ 07-redis介绍│ │ 08-redis的安装和数据类型介绍│ │ 09-redis字符串操作常用命令│ │ 10-list常用操作命令│ │ 11-set类型常用命令│ │ 12-sortedset操作常用命令│ │ 13-hash类型常用命令│ │ 14-key操作相关的命令│ │ 15-redis的配置文件│ │ 16-redis数据的持久化│ │ 17-hiredis的安装│ │ 18-hiredis 常用api讲解│ │ 19-mysql数据库设置远程访问│ │ 20-mysql设置utf8字符集│ │ 21-mysql设置字段名大小写不敏感│ │ 22-navicat介绍│ │ 23-shell脚本基本语法│ ││ ├─传智云pan项目- 03天│ │ │ 01-教学资料.zip│ │ ││ │ └─03-视频│ │ 01-redis命令复习│ │ 02-redis的配置文件│ │ 03-知识点概述│ │ 04-ngxin介绍│ │ 05-正向代理和反向代理│ │ 06-ngxin服务器的安装和测试│ │ 07-ngxin操作相关的指令│ │ 08-ngxin的配置文件│ │ 09-ngxin静态网页的部署│ │ 11-域名和IP相关知识点│ │ 12-反向代理准备工作│ │ 13-反向代理的设置│ │ 14-负载均衡的设置│ │ 15-反向代理和负载均衡总结│ │ 16-shell中的变量│ │ day3-10-复习│ ││ ├─传智云pan项目- 04天│ │ │ 传智云pan项目- 04天.zip│ │ ││ │ └─03-视频│ │ 02-ngxin知识点回顾│ │ 03-为什么要使用cgi│ │ 04-http协议回顾│ │ 05-cgi和fastCGI的工作模式│ │ 06-fastCGI介绍│ │ 07-fastCGI和spawn-fcgi的安装│ │ 08-spawn-fcgi是如何工作的│ │ 09-nginx配置fastcgi│ │ 10-nginx和fastCGI - spawn-fcgi协工作演示│ │ 11-知识点回顾│ │ 12-通过部署web界面实现文件的上传操作步骤│ │ 13-文件上传流程演示│ │ 14-post提交数据的四种方式│ │ 15-nginx和fastcgi的部署总结│ │ day4-01-知识点概述│ ││ ├─传智云pan项目- 05天│ │ │ 传智云pan项目- 05天.zip│ │ ││ │ └─2-视频│ │ 02-fastCGI复习│ │ 03-图片上传流程图│ │ 04-图片的下载-需求│ │ 05-nginx中添加fastDFS模块-上│ │ 06-nginx中添加fastdfs模块-下│ │ 07-nginx服务器的配置│ │ 08-nginx中添加fastdfs模块流程回顾│ │ 09-上传文件服务器端cgi程序讲解│ │ 10-Qt创建搭建 - 标题窗口│ │ 11-qt窗口如何添加背景图片│ │ 12-登录界面搭建│ │ 13-窗口的拖动│ │ day5-01-知识点概述│ ││ ├─传智云pan项目- 06天│ │ └─03-视屏│ │ 02-项目的整体架构│ │ 03-文件的下载流程│ │ 04-Qt界面制作复习│ │ 05-登录窗口切换│ │ 06-Qt中正则表达式的使用│ │ 07-Qt中json类的使用│ │ 08-使用json类写json文件│ │ 09-使用json类读json文件│ │ 10-项目中的配置文件介绍│ │ 11-qt中http协议处理上│ │ 12-qt中处理http协议的三个类│ │ 13-qt中使用http协议通信测试程序│ │ 14-项目需要的数据库表│ │ 15-md5介绍│ │ 16-qt中生成md5字符串│ │ 17-base64介绍│ │ 18-base64在qt中的使用│ │ day6-01-知识点概述│ ││ ├─传智云pan项目- 07天│ │ │ 传智云pan项目- 07天.zip│ │ ││ │ └─03-视屏│ │ 02-复习│ │ 03-注册流程上│ │ 04-json配置文件的读写操作│ │ 05-注册流程│ │ 06-项目server端部署流程│ │ 07-项目客户端部署流程│ │ 08-common.h文件讲解上│ │ 09-common.h文件讲解中│ │ 10-common.h文件讲解下│ │ 11-注册用户代码实现│ │ 12-服务器端cgi注册代码实现│ │ day701-知识点概述│ ││ ├─传智云pan项目- 08天│ │ │ 传智云pan项目- 08天.zip│ │ ││ │ └─03-视屏│ │ 02-注册流程回顾│ │ 03-登录流程│ │ 04-登录代码│ │ 05-登录保存用户信息的单例模式类│ │ 06-服务器处理登录代码│ │ 07-解题思路│ │ 08-关于数据传输安全的问题│ │ 09-发布Qt程序找dll的方式│ │ 10-自定义的buttongroup│ │ 11-上传数据添加到任务队列处理│ │ 12-md5秒传操作│ │ 13-上传文件的流程│ │ 14-任务处理的生产者和消费者模型│ │ 15-Qt中通过代码布局窗口│ │ 16-Qt中如何使用线程的UI类│ │ day8-01-知识点概述│ ││ ├─传智云pan项目- 09天│ │ └─03-视频│ │ 02-qt中右键菜单的显示│ │ 03-信号映射类QSignalMapper│ │ 04-显示文件内容相关的协议│ │ 05-请求服务器获取文件内容│ │ 06-文件的下载流程│ │ 07-分享文件先关的协议│ │ 08-项目流程回顾-上│ │ 09-项目流程回顾-下│ ││ └─传智云pan项目- 10天│ └─03-视频│ 01-shell脚本的创建│ 02-shell脚本中的基础知识│ 03-条件判断语句│ 04-[[和[的区别│ 05-if语句语法格式│ 06-if在shell脚本中的使用│ 07-case语句语法│ 08-sehll中for语法│ 09-while语法│ 10-重定向│ 11-awk的使用上│ 12-awk的使用 - 变量操作│ 13-fastdfs.sh脚本│ 14-fcgi.sh脚本文件│ 15-redis.h脚本│└─13移动打车项目 ├─01-java基础 │ └─3-视频 │ 1-项目架构概述 │ 10-java中的finalize函数 │ 11-java中的String类型 │ 12-java中的文件操作 │ 13-java中的abstract关键字 │ 14-java中的interface和implements关键字 │ 15-java中的import │ 16-部署android开发环境 │ 2-java中的helloworld │ 3-java中的定义类 │ 4-java语言的值传递和引用传递 │ 5-java中的常量和静态变量 │ 6-java中静态成员方法 │ 7-java中的继承extents和instanceof关键字 │ 8-java中的数组定义和传参 │ 9-中午复习-java中的时间 │ ├─02-Android-UI │ └─2-Android-UI │ └─3-视频 │ 1 项目的演示 │ 10-Activity的生命周期 │ 11-autoCompleteTextView控件 │ 12-交叉编译和ndk介绍 │ 2-创建android项目 │ 3-创建textView控件 │ 4-创建button控件 │ 5-editText控件 │ 6-checkBox控件 │ 7-完成登陆界面的布局 │ 8-Activity之间的跳转 │ 9-完成注册界面布局 │ ├─03-Android和JNI接口封装 │ └─3-视频 │ 1-jni的环境配置 │ 2-Android调用jni方法 │ 3-jni测试传参int类型接口 │ 4-jni测试bool类型传参 │ 5-jni测试String类型传参 │ 6-jni测试数组传参 │ 7-登陆login的jni接口封装 │ 8-libcurl的安装 │ ├─04-libcurl编程 │ └─3-视频 │ 1-login模块集成cJSON接口 │ 2-libcurl的简单编程 │ 3-libcurl发送post请求 │ 4-测试post请求 │ 5-libcurl编程处理从服务器返回的数据 - 副本 │ 6-Android上部署libcurl_ - 副本 │ 6-Android上部署libcurl │ 7-实现登陆模块和服务器通信调试 │ ├─05-curl-json类封装-搭建https服务器 │ └─3-视频 │ 1-实现REG模块jni接口-封装cJSON接口对象 │ 2-实现reg模块的jni接口-封装Curl类 │ 3-reg和http服务器通信调试 │ 4-https认证过程 │ 5-测试https客户端服务端通信 │ ├─06-web服务器存储服务器通信联调-git常用指令 │ └─3-视频 │ 1-通信协议的介绍 │ 2-前端和webserver的reg流程通信调试 │ 3-web服务器发送存储请求 │ 4-webserver和dataserver通信联调 │ 5-sessionid随机字符串的创建 │ 6-git代码版本管理工具的简介 │ 7-使用git指令修改并提交代码 │ 8-使用git添加文件 │ 9-git删除文件和解决冲突 │ ├─07-高de地图和定位服务 │ └─3-视频 │ 1-创建高de地图的key │ 10-以自我为中心展示地图 │ 11-搭建司机和乘客的界面 │ 2-配置高de地图的so和jar包环境 │ 3-显示高de地图 │ 4-得到amap对象-显示实时交通信息 │ 5-通过按钮操作地图切换类型 │ 6-uiSettings控件交互 │ 7-开启定位服务 │ 8-给定位客户端设置属性更换定位频率 │ 9-在地图上添加当前位置的覆盖物 │ ├─08-高de地图搜索兴趣点-打车项目业务 │ └─3-视频 │ 1-昨日回顾 │ 10-redis中的geo相关指令 │ 11-司机的业务(下) │ 12-乘客下单流程 │ 13-乘客的业务 │ 14-完成订单业务 │ 15-git提交项目代码的复习 │ 2-有关poi兴趣点的搜索 │ 3-线路规划和绘制驾驶路径 │ 4-inputtips关键字模糊搜索 │ 5-乘客和司机的状态机avi │ 6-数据库表设计 │ 7-登陆和注册业务 │ 8-司机的业务(上) │ 9-GEO地理位置编码 │]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020上教师资格证 ☆☆☆热☆☆☆]]></title>
    <url>%2F2019%2F12%2F01%2F001%E5%BF%85%E7%9C%8B%2F</url>
    <content type="text"><![CDATA[资料：科目1(综合素质)：18.8元，科目2(教育知识与能力)：19.9元，在文章底部扫码付款后可获取密码，然后回到主页紧接下一个文章提取百度网盘资源，有问题可私聊qq：4090116162020年上半年教师资格证考试时间安排：笔试报名1月份，笔试时间3月份1、资源来之不易,本人亲自整理，涵盖教育知识与能力(科目二)、综合素质(科目一)所有考点;2、 相比书本、各种资料繁杂，不易学习记忆，扰乱军心(信心) ;3、本资料特点，简单容易记忆，注意啦，他是上手就能背，背了就能得分，认真看，必过！！！4、拿综合素质举个例子，综合素质上手，保证你15分钟内搞定大题，妈妈，再也不用担心我的学习啦~5、教育知识与能力相对较难，不准备，想过门都没有，我这里都给你准备的妥妥的，看了，必过！！6、使用这份资料，认真准备,轻松过关不是难事! ! !7、 拥有这套资料后，大家不要再迷失方向，胡乱找资料，看网课，这些都没用！！只会耽误时间！！！抓紧时机看我的资料保证没问题！！！8、最后，我祝愿大家能够考出一个好成绩9、如有问题可以问我，我为大家排忧解难! ! !我与大家同在! ! !]]></content>
      <categories>
        <category>考试</category>
      </categories>
      <tags>
        <tag>教师资格证考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普通话考试]]></title>
    <url>%2F2019%2F12%2F01%2F000%E6%99%AE%E9%80%9A%E8%AF%9D%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[普通话通关全套资料：19.9元，在文章底部扫码付款后可获取密码，然后回到主页紧接下一个文章提取百度网盘资源，有问题可私聊qq：409011616]]></content>
      <categories>
        <category>考试</category>
      </categories>
      <tags>
        <tag>普通话考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020上教师资格证资料领取 ☆☆☆热☆☆☆]]></title>
    <url>%2F2019%2F12%2F01%2F001%E6%95%99%E5%B8%88%E8%B5%84%E6%A0%BC%E8%AF%81%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[付款后才可以领取资料料哦！如遇到问题请咨询qq:4090116161、资源来之不易,本人亲自整理，涵盖教育知识与能力(科目二)、综合素质(科目一)所有考点，由于科目三科目众多，尚待更新，请大家持续关注！！2、 相比书本、各种资料繁杂，不易学习记忆，扰乱军心(信心) ;3、本资料特点，简单容易记忆，注意啦，他是上手就能背，背了就能得分，认真看，必过！！！4、拿综合素质举个例子，综合素质上手，保证你15分钟内搞定大题，妈妈，再也不用担心我的学习啦~5、教育知识与能力相对较难，不准备，想过门都没有，我这里都给你准备的妥妥的，看了，必过！！6、使用这份资料，认真准备,轻松过关不是难事! ! !7、 拥有这套资料后，大家不要再迷失方向，胡乱找资料，看网课，这些都没用！！只会耽误时间！！！抓紧时机看我的资料保证没问题！！！8、最后，我祝愿大家能够考出一个好成绩9、如有问题可以问我，我为大家排忧解难! ! !我与大家同在! ! !]]></content>
      <categories>
        <category>考试</category>
      </categories>
      <tags>
        <tag>教师资格证考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019最新尚硅谷大数据全套视频（2019年6月毕业班）]]></title>
    <url>%2F2019%2F12%2F01%2F006%E5%B0%9A%E7%A1%85%E8%B0%B7%2F</url>
    <content type="text"><![CDATA[全套35元！！！高清无加密在文章底部扫码付款后可获取密码，然后回到主页紧接下一个文章提取百度网盘网盘，有问题可私聊qq：409011616尚硅谷大数据线下班全套视频（2019年6月毕业班）|040_面试题讲解.rar|039_面试视频.rar|038_在线教育项目实战.rar|037_Flink项目.rar|036_Flink.rar|035_实时项目.rar|034_电商分析平台项目.rar|033_Spark调优.rar|032_Spark.rar|031_Scala数据结构和算法.rar|030_Scala.rar|029_阶段考试.rar|028_ELK.rar|026_Ambari.rar|025_Kettle.rar|024_ClickHouse.rar|023_Hue.rar|022_Impala.rar|021_CDH安装.rar|020_Kylin.rar|019_azkaban.rar|018_Oozie.rar|017_Sqoop.rar|016_HBase.rar|015_Kafka.rar|014_Flume.rar|013_Hive.rar|012_Zookeeper.rar|011_Hadoop.rar|010_Shell.rar|009_JVM&amp;JUC.rar|008_Git.rar|007_MySQL高级.rar|006_Redis.rar|005_Linux.rar|004_SpringBoot.rar|003_Spring.rar|002_Maven.rar|001_WEB.rar|000JavaSe]]></content>
  </entry>
  <entry>
    <title><![CDATA[某马(hm)Java57期百度网盘 ☆☆☆顶☆☆☆]]></title>
    <url>%2F2019%2F12%2F01%2F005java%E7%99%BE%E5%BA%A6%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[全套30元！！！有问题可私聊qq：409011616百度网盘链接：https://pan.baidu.com/s/.........................出现bug,如果已经付款，请咨询qq409011616....................................................提取码：ac0c请联系qq409011616]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019年最新某马(hm)Python+人工智能在线就业班百度网盘资源 ☆☆☆新☆☆☆]]></title>
    <url>%2F2019%2F12%2F01%2F004python24%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[Python+人工智能在线就业班百度网盘资源….百度网盘Python+人工智能在线就业班百度网盘资源，全套不加密链接：https://pan.baidu.com/s/1......................................................................................出现bug,如果已经付款，请咨询qq409011616.............................................链接：https://pan.baidu.com/s/1ucd.............bug...........提取码：xxx,付款66元后请联系qq:409011616]]></content>
  </entry>
  <entry>
    <title><![CDATA[尚硅谷大数据线下班全套视频（2019年6月毕业班）]]></title>
    <url>%2F2019%2F12%2F01%2F006%E5%B0%9A%E7%A1%85%E8%B0%B7%E7%99%BE%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[全套35元！！！有问题可私聊qq：409011616百度网盘链接：https://pan.baidu.com/s/.........................出现bug,如果已经付款，请咨询qq409011616....................................................提取码：a854请联系qq409011616]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019年最新某马(hm)Python+人工智能在线就业班 ☆☆☆新☆☆☆]]></title>
    <url>%2F2019%2F12%2F01%2F003python%2B%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%2F</url>
    <content type="text"><![CDATA[全套66元！！！在文章底部扫码付款后可获取密码，然后回到主页下一个文章提取百度网盘资源，有问题可私聊qq：409011616Python+人工智能在线就业班阶段1 : Python核心编程 1-1 Python基础V4.1 第1节 Python介绍 001_计算机硬件系统 002_计算机软件系统 003_python语言简介 004_python语言特点 第2节 pycharm的基本使用 05Python解释器安装-windows版本 05Python集成开发环境安装-windows版本 05Python解释器安装-mac版本 05Python集成开发环境安装-mac版本 005_第一个程序hello python 006_第一个程序常见BUG 007_PyCharm基本使用 008_PyCharm使用技巧（基础技巧） 009_Debug模式初级操作 010_多文件管理 011_多项目管理 课后练习 第3节 Python基础语法 015_注释 016_注释的作用 017_提示性信息 018_算数运算符 019_算数运算符优先级示例 020_变量的概念 021_变量的使用 022_变量在内存中的执行过程分析 023_变量命名规则 025_案例：计算圆面积 026_变量类型 027_赋值运算 028_字符串运算 029_标准输入 030_标准输入的注意事项与类型转换 031_格式化输出 032_计算圆面积（输入输出版） 033_比较运算符 034_字符串间的比较运算 035_关系运算符 036_数字参与关系运算 课后练习 第4节 分支语句 037_if结构 038_if..else..结构 039_if..elif..else..结构 040_减肥计划 041_分支嵌套 042_外卖结算 043_超长行处理 课后练习 第5节 循环语句 044_while结构 045_循环变量与死循环 046_数字累加求和 047_循环误区 048_回文数 049_回文数输出格式改造 050_break与continue 051_循环嵌套 052_循环嵌套练习 053_九九乘法表 054_循环嵌套中的break与continue 课后练习 第6节 函数基础使用 055_函数 056_函数定义 057_函数调用过程分析 058_文档注释 059_函数定义——参数 060_形参与实参 061_最大值 062_作用域 063_函数定义——返回值 064_返回值 065_函数间调用 066_三个数字求最大值 课后练习 第7节 面向对象基础 067_面向对象 068_类和对象 069_类的组成 070_类定义与创建对象 071_成员变量定义与调用 072_成员方法定义与调用 073_init方法与魔术方法 074_str方法 075_成员方法调用成员 077_手机案例 078_手机加强版案例 079_封装 080_init传参 课后练习 第8节 面向对象高级 081_类变量 082_类方法 083_方法第一个参数理解误区 084_静态方法 085_面向对象名称总结 086_继承的基础语法 087_继承关系结构图 088_重写 089_重写关系中调用父类被覆盖的方法 090_多继承 091_多态 092_鸭子类型 093_引用类型参数 094_引用类型参数内存工作原理 095_反恐精英案例解析 096_反恐精英基础版 097_反恐精英修复版 098_反恐精英加强版 099_反恐精英超级加强版 课后练习 1-2 Python核心编程V4.1 第1节 列表、元组、集合、字典 100_列表 101_列表的应用 102_元组 103_元组数据修改 104_元组的应用 105_集合 106_集合的应用 107_列表元组集合间格式转换 108_字典 109_字典的应用 110_range 111_列表常用操作 112_元组、集合常用操作 113_字典常用操作 114_数据存储结构嵌套 116_斗地主案例需求分析 117_1_斗地主结构设计 117_2_斗地主初始化牌堆 117_3_斗地主洗牌 117_4_斗地主发牌 118_公共函数 119_切片 120_通用运算符 121_循环else语句 122_推导式 课后练习 第2节 字符串 123_字符串 124_字符串基本操作 125_字符串判断型操作 126_字符串数据转换型操作 127_字符串格式转换型操作 128_字符串拆分与连接操作 129_字符串查找与替换操作 130_加密解密（了解） 131_字符串切片与常用操作 132_找出真凶 课后练习 第3节 函数高级用法 133_默认参数 134_参数格式混用一 135_默认参数的应用场景 136_关键字参数 137_参数格式混用二 138_关键字参数的应用场景 139_可变参数 140_参数格式混用三 141_可变参数应用场景 142_字典参数 143_参数格式混用四 144_字典参数应用场景 145_字典参数形参操作 146_递归函数 147_匿名函数 148_匿名函数使用注意事项 149_函数返回值（回顾） 课后练习 第4节 引用 150_引用 151_引用（数值、布尔、字符串） 152_引用（变量内存结构图） 153_引用（数值、布尔、字符串特殊现象） 154_引用（列表） 155_引用（列表内存工作原理） 156_引用（列表内存底层工作原理） 157_引用（元组） 158_引用（集合） 159_引用（集合底层存储原理） 160_引用（字典） 161_引用（字典底层存储原理） 162_引用（对象） 163_引用（对象底层存储原理） 164_可变类型与不可变类型 165_函数实参类型 166_函数实参类型（形参使用默认参数） 课后练习 第5节 对象管理 167_new方法 168_del操作 169_del方法 170_is操作 171_单例模式 172_1_办公室的打印机 172_2_办公室的打印机（改造方式1） 172_3_办公室的打印机（改造方式2） 课后练习 第6节 文件操作 173_文件基本操作 174_文件读写模式 175_文件读操作 176_文件写操作 177_文件路径 178_文件相关操作 179_windows复制文件 课后练习 第7节 异常处理 180_异常处理方案一 181_异常处理方案二 182_异常处理方案三 183_捕获具体异常 184_获取具体的异常描述信息 185_异常出现原理 186_异常处理机制 187_自定义异常 188_用户登录信息校验 课后练习 第8节 模块和包 189_模块的定义 190_模块全部导入 191_模块局部导入 192_模块局部导入资源访问控制 193_模块运行代码管理 194_模块资源加载底层工作原理 195_模块加载路径 196_包 197_用户登录信息校验改造 1-3 【项目】飞机大战V4.1 第1节 项目准备 01_项目分析 02_项目创建与pygame安装 第2节 背景窗口 03_模型初始化 04_窗体初始化 05_窗体设置 06_关闭窗体(事件机制) 07_背景制作 08_抽取变量 09_模型抽取 10_背景移动 11_背景反复移动 12_添加辅助背景 第3节 飞机交互 13_敌机加入(单个) 14_敌机移动(单个) 15_敌机加入(多个) 16_敌机移动控制(多个) 17_敌机随机贴图控制(多个) 18_玩家飞机加入 19_玩家移动控制 20_获取鼠标左键按下状态 21_发射子弹 22_子弹移动控制 23_碰撞检测 24_碰撞处理 阶段2 : Python和Linux高级编程 2-1 Linux基础V3.2 第1节 操作系统介绍 01-课程介绍 02-操作系统的介绍 03-操作系统的领域、虚拟机的介绍 04-操作系统历史介绍 05-ubuntu基本使用 第2节 linux命令(一) 06-Linux基本命令-1 07-Linux基本命令-2 08-Linux基本命令-3 09-Linux基本命令-4-相对路径、绝对路径、rm等 10-Linux基本命令-5-cp、mv、tree、history等 第3节 linux命令(二) 02-Linux命令：ls 03-Linux命令：重定向 04-Linux命令：cat、more、管道 05-Linux命令：软连接、硬链接 第4节 linux命令(三) 06-Linux命令：cat合并文件、grep、find、通配符 07-Linux命令-压缩 08-Linux命令：chmod权限修改 09-Linux命令：sudo、ssh、who、reboot等 第5节 ubuntu 安装软件以及共享文件 10-Ubuntu安装软件的流程 11-Ubuntu共享文件的方式：拖拽、ftp、scp 第6节 vim 基本使用 12-vim基本使用 2-2 网络编程v3.1 第1节 基本概念 01-网络通信概述 02-IP地址 03-Linux、windows查看网卡信息 04-ip地址的分类-ipv4和ipv6介绍 05-（重点）端口 06-端口分类：知名端口、动态端口 07-socket介绍 第2节 udp 08-udp发送数据demo-1 09-udp发送数据-demo-2 10-关闭VMware的虚拟网卡（了解） 11-udp发送数据的强调 12-（重点）运行python程序以及python交互模式，encode编码，发送udp的练习 13-（重点）接收udp数据 14-（重点）端口绑定的问题 15-网络中重要概念复习 16-输入对方ip、port、全双工、半双工、单工等 17-案例：udp聊天器 课后练习 第3节 tcp客户端 01-tcp介绍 02-（重点）tcp客户端 课后练习 第4节 tcp服务器 03-（重点）tcp服务器-1 04-（重点）tcp服务器-2-循环为多个客户端服务 05-（重点）tcp服务器-3-循环为多个客户端服务 课后练习 第5节 tcp下载文件 06-案例：下载文件 07-知识点快速总结，listen里的参数 08-QQ不绑定端口、昨日知识点复习 课后练习 2-3 多任务v3.1 第1节 线程 01-多任务介绍、以及Thread的基本使用 02-Thread创建线程 完成多任务 03-查看正在运行的线程、主线程等待子线程先结束 04-通过继承Thread类完成创建线程 05-通过继承Thread类完成创建线程-补充 06-多线程共享全局变量 07-多线程共享全局变量-args参数 08-创建线程是指定传递的参数、多线程共享全局变量的问题 09-同步概念、互斥锁解决资源竞争的问题 10-死锁、银行家算法 11-案例：多线程版udp聊天器 课后练习 第2节 进程 01-线程知识点复习 02-进程、程序的概念 03-使用Process完成多进程 04-使用Process完成多进程-补充 05-获取pid、ppid、给Process传递参数、运行顺序不确定、主进程等待子进程先结束、进程不共享全局变量 06-进程、线程的区别 07-通过队列完成进程间通信 08-进程池概述 09-进程池的创建 10-案例：多任务文件夹copy 课后练习 第3节 协程 01-迭代器 02-完善迭代器 03-（重点）迭代器的应用 04-迭代器使用的其他方式 05-生成器-1 06-生成器-2-send方式 07-（重点）生成器-小总结 08-使用yield完成多任务 09-使用greenlet、gevent完成多任务 10-案例：图片下载器 11-（重点）进程、线程、协程对比 课后练习 2-4 【项目】web服务器v3.1 第1节 正则表达式 01-正则表达式简介 02-匹配单个字符-1 03-匹配单个字符-2 04-匹配多个字符 05-案例：简单判断变量名是否符合要求、匹配结尾开头 06-案例：简单判断email、转义 07-分组等 08-re的高级用法：search、sub等 09-案例：提取数据内容，清除不要的杂数据 10-r的作用 课后练习 第2节 http协议 01-此阶段知识的介绍 02-HTTP协议的通俗讲解 03-通过网络调试助手充当http服务器来验证http协议 第3节 简单web服务器实现 04-案例：返回固定页面的http服务器 05-tcp3次握手、4次挥手 06-tcp3次握手、4次挥手-强调 07-案例：返回浏览器需要的页面http服务器-介绍 08-案例：返回浏览器需要的页面http服务器-代码实现 课后练习 第4节 并发web服务器实现 01-http协议复习 02-多进程、线程实现http服务器 03-多进程、线程实现http服务器-补充 04-gevent实现http服务器 05-（重要）单进程、线程、非堵塞实现并发的原理 06-单进程、线程、非堵塞实现并发的验证-1 07-单进程、线程、非堵塞实现并发的验证-2、debug的思想 08-知识点补充，把对象append到列表时，仅仅是添加了对象的引用 09-长连接、短连接 10-单进程、线程、非堵塞、长连接的http服务器 11-（重要）epoll的原理过程讲解 12-epoll版的http服务器 课后练习 第5节 网络通信 01-tcp ip协议 02-wireshark抓包工具-安装 03-wireshark抓包工具-使用 04-2台电脑通信、网络掩码 05-集线器、交换器组网、arp获取mac地址等 06-路由器链接多个网络、默认网关 07-浏览器访问服务器的过程 08-ip不变、mac地址发生变化 2-5 Python高级语法v3.1 第1节 GIL锁 01-GIL-1 02-GIL-2 第2节 深拷贝和浅拷贝 03-深拷贝、浅拷贝-1 04-深拷贝、浅拷贝-2 05-深拷贝、浅拷贝-3 06-深拷贝、浅拷贝-4 课后练习 第3节 私有化、import、封装继承多态 07-私有化 08-import导入模块 09-多个模块import导入注意点 10-再议封装、继承、多态 课后练习 第4节 方法解析顺序表MRO 01-（重点）多继承中的MRO顺序 02-（重点）※args、※※kwargs的另外用处拆包 03-单继承中MRO、继承的面试题 课后练习 第5节 类对象和实例对象访问属性的区别和property属性 04-类对象、实例对象、类方法、实例方法、类属性、实例属性、静态方法 05-（重点）property属性 06-property属性的应用 07-创建property属性的方式-装饰器 08-创建property属性的方式-类属性 09-property属性的应用2 课后练习 第6节 私有属性和名字重整、魔法属性和方法、上下文管理器 10-修改、查看私有属性、名字重整 11-魔法属性、方法 12-面向对象设计 13-（重点）with、上下文管理器 课后练习 2-6 MySQL数据库v3.1 第1节 数据库的基本使用 01-课程介绍 02-数据库介绍 03-RDBMS、MySQL介绍 04-MySQL服务器、客户端安装以及使用 05-通过navicat操作数据库 06-数据类型、约束 07-（重点）-数据库的操作 08-（重点）-数据表的操作 09-（重重点）-数据的增删改查 第2节 数据库查询 01-课程介绍 02-数据准备、基本的查询 03-条件查询 04-范围查询、null 05-排序 06-聚合、分组 07-分页 08-链接查询 09-自关联 10-子查询-简单 11-数据库设计 第3节 MySQL与Python交互 01-数据的准备，基本查询 02-数据操作演练：拆为多个表 03-数据操作演练：拆为多个表2 04-python安装pymysql 05-python操作sql：查询数据 06-案例：京东商城-查询 07-python操作sql：添加、修改、删除数据 08-案例：京东商城-添加，防止SQL注入 09-作业要求 第4节 MySQL高级 01-视图 02-事务-1 03-事务-2 04-索引-1 05-索引-2 06-（了解）账户管理 07-MySQL主从 2-7 【项目】mini-web框架v3.1 第1节 WSGI-mini-web框架 01-课程介绍 02-多进程-面向对象-web服务器 03-静态资源、动态资源、web服务器支持动态解析 04-静态、动态资源强调 05-实现很简单的框架，让web服务器支持 06-（重点）WSGI的介绍 07-web服务器支持WSGI 08-web服务器通过字典将需要的参数传递给mini_frame框架 09-mini_frame获取页面模板数据 10-mini_frame替换模板中的数据，成为一个新页面 11-给程序传递参数、添加web服务器的配置文件、添加shell功能 课后练习 第2节 闭包 01-闭包-1 02-闭包-2 03-闭包-3-补充 04-闭包-4-修改数据 课后练习 第3节 装饰器 05-装饰器-1-介绍 06-装饰器-2-手动实现装饰器 07-装饰器-3-作用demo、对有参数函数、无参数函数的装饰 08-装饰器-4-再理解 09-装饰器-5-不定长参数的函数装饰 10-装饰器-6-对应有返回值函数进行装饰、通用装饰器 11-装饰器-7-多个装饰器对同一个函数装饰 12-装饰器-8-多个装饰器对同一个函数装饰demo 13-装饰器-9-（了解）用类对函数进行装饰 课后练习 第4节 mini-web框架添加路由和MySQL功能 01-带有参数的装饰器 02-用装饰器完成路由功能-1 03-用装饰器完成路由功能-2 04-用装饰器完成路由功能-3 05-用装饰器完成路由功能-4 06-静态、动态、伪静态url 07-让web服务器支持伪静态 08-mini_frame框架添加MySQL功能-1 09-mini_frame框架添加MySQL功能-2 课后练习 第5节 mini-web框架添加正则和log日志功能 01-今日课程介绍 02-路由支持正则 03-关注股票 04-取消关注 05-更新备注信息 06-url编解码 07-log日志功能 课后练习 第6节 元类 01-类也是对象、globals查看所有的全局对象引用 02-元类创建类，类创建实例对象 03-通过type来创建复杂的类，元类应用demo 04-元类应用demo-补充 课后练习 第7节 orm 05-orm介绍 06-orm-实现 07-orm-实现2 08-python高级知识快速复习-1 09-python高级知识快速复习-2 课后练习 阶段3 : 前端开发 3-1 HTML和CSSV4.0 第1节 前端简介与常用HTML标签 001前端开发环境 002环境设置 003前端开发概述 004html语言概述 005html基本结构 006快捷键创建网页 007常用标签 008字符实体 009通用块元素标签 010常用内联元素标签 011布局基本步骤 012标签语义化和精简标签 第2节 css选择器一与列表 013css介绍 014样式的引入方式 015css选择器 016常用样式设置 017步骤最终效果 001反馈 002复习 003相对地址和绝对地址 004列表标签 005列表样式 006列表标签相关笔记 第3节 css选择器二、表单与盒子模型布局 007创建表单01 008表单创建02 009css选择器二 010盒子模型 011表单布局实例 001反馈 002复习 003设置块元素相对于父级水平居中 004元素显示特性 005元素溢出 第4节 元素定位、表格、弹框、photoshop 006创建表格 007表格样式 008相对定位 009绝对定位和固定定位 010定位元素层级 011弹框 012弹框02 013css权重值 014photoshop操作01 015photoshop操作02 016photoshop操作03 017前端页面开发流程 3-2 JavaScript和JQueryV4.0 第1节 JavaScript基本语法与小案例 003javascript介绍 004js嵌入方式 005javascript基本语法 006函数 007条件语句 008获取元素 009操作元素属性 010事件属性 011匿名函数 012网页换肤 013打印名片 第2节 JavaScript数组与字符串 004函数传参-return关键字 005函数传参补充 006数组及操作方法 007循环语句-数组去重 008将数组的数据放入页面 009字符串操作01 010字符串操作02 第3节 JavaScript定时器与动画 011创建定时器 012定时器制作移动动画 013定时器制作左右移动动画 014无缝滚动原理讲解 015无缝滚动代码实现 003调试程序的方法 004变量作用域-相关笔记 005封闭函数 第4节 jQuery介绍与jQuery选择器 006jquery介绍 007jquery文档加载完再执行 008jquery选择器 009选择集过滤 010选择集转移 011操作行间样式 012操作样式类名 第5节 jQuery选项卡、动画、聊天框 013绑定click事件-this关键字-索引值 014选项卡 015动画 003判断是否选中了元素 004动画参数 005特殊动画效果 006层级菜单 007操作元素属性 008聊天对话框 第6节 jQuery表单、事件 009表单相关事件 010正则表单式 011表单验证 002常用事件-focus-click 003常用事件-鼠标移入移出1 004常用事件-鼠标移入移出2 005事件冒泡 006阻止事件冒泡 007弹框 008事件委托 第7节 jQuery Dom操作与案例 009dom操作1（里面的前后） 010dom操作2 011todolist-添加功能 012todolist-删除功能 013todolist-上下移动功能 014相关笔记 第8节 JavaScrip对象与ajax 015javascript对象 016json 017读取txt文件 018读取json-读取首页数据 003ajax向服务器发送数据 004ajax的写法 005ajax相关概念（全刷新） 006ajax相关概念（局部刷新） 3-3 Vue.jsV4.0 第1节 Vue基本语法选项卡事件处理 007vuejs简介 008vue基本语法01 009vue基本语法02 010vue基本模板语法 011class绑定 012选项卡 013条件渲染 014事件处理 015vue制作弹框 002列表循环 第2节 Vue表单、过滤器、数据请求和ES6 003表单数据绑定01 004表单数据绑定02 005聊天对话框 006计算属性和侦听属性 007过滤器简介 008过滤器代码实现 009vue对象生命周期 010数据请求-函数介绍 011数据请求-在miniweb的实现 012es6-变量声明关键字 013es6-箭头函数 003es6语法 第3节 Vue组件开发与miniweb Vue案例 004创建组件 005创建组件02 006单文件组件 007终端命令 008环境安装 009项目目录结构及文件结构 010组件嵌套 011路由嵌套组件 012miniweb实战（路由-页面拼接） 013miniweb实战（股票信息页面数据组装） 014miniweb实战（添加删除） 015miniweb实战（修改） 016miniweb实战（打包上线） 阶段4 : Web 开发 4-1 Flask框架V4.0 第1节 web访问流程和虚拟环境安装 1.1Web访问流程 1.2Web应用程序本质 1.3为什么要搭建虚拟环境 1.4虚拟环境的安装 第2节 app创建和运行时的参数 2.1HelloWorld程序 2.2Flask创建时候的参数 2.3Flask程序的配置加载 3.1app运行的参数 第3节 请求方式和视图的返回值 3.2路由的参数与请求方式指定 3.3PostMan模拟发送请求 3.4JSON数据格式&amp;返回JSON 4.1重定向 4.2自定义状态码 第4节 正则转换器和错误捕获 4.3正则转换器定义 4.4正则自定义转换器 5.1转换器to_python 5.2转换器to_url 5.3错误捕获 第5节 请求钩子和装饰器路由实现 6.1请求勾子函数 6.2请求勾子函数案例 1.1装饰器路由的实现 第6节 cookie和session 1.2接收请求的参数 1.3无状态引入 2.1cookie的交互流程 2.2设置和获取cookie 2.3session的交互流程 3.1session的代码演练 第7节 请求上下文和应用上下文 3.2请求上下文和应用中下文 4.1Flask-script的使用 第8节 模板 4.2Jinja2模板介绍 4.3模板的数据显示 5.1字符串和列表过滤器 5.2参数过滤器 5.3自定义过滤 6.1控制代码块 1.1宏的使用 1.2html继承 1.3模板抽取演练 2.1包含&amp;小结 第9节 wtf表单 2.3原生的Form表单 3.1WTF表单界面显示 3.2WTF表单验证 3.3CSRF原理分析 4.1解决CSRF攻击 4.2Flask项目中解决CSRF攻击 第10节 数据库 4.3ORM简单介绍 5.1SQLAlchemy配置 5.2添加模型&amp;增删改 5.3数据库一对多的关系定义 6.1数据库简单查询 6.2数据库过滤查询 6.3数据库排序分页查询 6.4断点调试(补充，不算到课程里面) 第11节 数据库综合案例 1.1综合案例-定义模型添加测试数据 1.2综合案例-界面数据展示 2.1综合案例-添加数据到数据库 2.2综合案例-数据库操作使用try 2.3综合案例-删除书籍及作者 3.1多对多关系介绍 3.2多对多关系演练 3.3-lazy指定 第12节 数据库迁移和信号 4.1数据库关联的模板代码 4.2数据库的迁移简介 4.3执行数据库迁移 4.4完善数据库迁移 5.1信号 第13节 蓝图和测试 5.2蓝图（单独文件使用） 5.3蓝图（模块形式使用蓝图） 6.1蓝图的静态文件和静态文件访问 6.2蓝图运行机制 6.3断言的使用 7.1单元测试编写 7.2数据库测试 4-2 Redis数据库V4.0 第1节 redis安装配置 1.1Redis的介绍 1.2Redis的安装 1.3Redis的配置 2.1Redis的服务端启动和客户端连接 第2节 redis数据类型以及操作 2.2Redis的string操作 2.3键命令 2.4Redis的hash操作 3.1Redis的list操作 3.2Redis的set操作 3.3Redis的zset操作 第3节 redis主从和集群 3.4Redis与Python交互 4.1Redis的主从 4.2集群的配置文件 4.3集群的搭建 5.1集群Python交互 4-3 Git版本管理V4.0 第1节 git简介 1.1GIT引入与简单介绍 1.2GIT源代码管理特点&amp;操作流程 第2节 git单人本地仓库操作 1.3工作区暂存区本地仓库 2.1GIT单人本地基本操作 2.2GIT回退&amp;撤消修改 2.3GIT对比版本&amp;删除 第3节 git远程仓库github 3.1多人协同开发引入&amp;GitHub介绍 3.2创建远程仓库&amp;拉取代码到本地 3.3GIT的协同开发推送到远端的操作 4.1GIT冲突演示 4.2GIT添加标签 4.3分支的使用 4-4 【项目】新经资讯V4.0 第1节 项目简介 5.1项目简单介绍 5.2项目技术实现介绍 5.3项目创建集成git 6.1将项目推送到码云 第2节 项目配置和项目目录结构组织 1.1项目配置创建&amp;数据库配置 1.2集成Redis&amp;CSRFProtect 1.3Session的保存位置指定&amp;测试 2.1Flask_Script和迁移命令集成 2.2抽取项目的配置到单独的文件 2.3抽取APP的创建逻辑到业务逻辑的模块里面 3.1抽取不同环境下的配置&amp;通过配置名字获取指定的配置 3.2抽取app创建到函数中&amp;配置名字作为参数 3.3日志简介 4.1集成日志到项目 4.2日志参数 4.3抽取蓝图目录(未抽取完毕) 5.1蓝图注册循环导入问题解决&amp;变量类型注释 第3节 数据库和模板 5.2数据库之创建主表 5.3数据库之创建关系表 6.1导入模型类&amp;数据库迁移&amp;测试数据导入 6.2静态文件的导入 1.1根路径的模板渲染 1.2加载favicon.ico图标 第4节 注册 1.3图片验证码生成流程 2.1引入验证码类文件 2.2请求图片验证码前端实现 2.3图片验证码的后端逻辑实现 3.1图片验证码的数据返回 3.2短信验证码实现思路分析 3.3-云通讯简单介绍 3.4集成短信验证码的工具类 4.1发送短信验证码的后端逻辑分析 4.2发送短信验证码的后端逻辑实现 4.3将验证码保存到redis 5.1前端代码分析 5.2发送短信验证码的前端逻辑实现 5.3发送短信验证码测试 6.1注册的后端逻辑实现 1.1注册的前端逻辑实现 1.2对密码的处理 1.3注册逻辑完善 第5节 登录 2.1登录的后端逻辑实现 2.2登录的前端逻辑实现 2.3用户是否登录的右上角内容显示 3.1退出的前后端逻辑实现 3.2SQLAlchemy的teardown的commit操作 3.3csrf校验分析 3.4csrf校验实现 第6节 首页新闻列表 4.1首页的排行列表新闻展示 4.2自定义过滤器实现排行列表标签class 5.1首页新闻列表分析 5.2首页新闻列表数据的后端实现 5.3首页新闻数据展示 6.1前端加载更多数据的实现 6.2首页分类点击加载数据 第7节 新闻详情页 02-详情页模板展示&amp;首页到详情页界面跳转 03-首页和详情页的基类模板抽取 04-新闻详情页基本模板数据显示 05-使用装饰器的形式去查询用户的登录信息 06-functools_wraps讲解 07-新闻详情页数据展示 第8节 新闻收藏评论和点赞 08-显示是否收藏的界面逻辑 09-是否收藏的后端逻辑 10-收藏和取消收藏后端逻辑实现 11-收藏和取消收藏的前端逻辑实现 12-评论新闻和回复别人评论的后端逻辑 13-评论新闻的前端逻辑实现 14-显示当前新闻的评论数据 15-子评论的回复 16-评论数量的更新显示 17-评论点赞和取消点赞的后端逻辑实现 02-点赞的前端逻辑实现 03-是否点赞的后端逻辑处理 04-点赞条数记录 第9节 个人中心 05-创建个人中心模块&amp;基类模板的抽取 06-基本资料界面展示 07-基本资料修改 08-上传头像的准备&amp;七牛的引入 09-七牛云上传的工具方法封装 10-上传头像的后端代码实现 11-上传头像的前端代码实现 第10节 修改密码、用户收藏和新闻发布 12-修改密码的前后端实现 13-用户收藏的前后端逻辑实现 03-新闻发布页面的界面展示 04-新闻发布的前后端逻辑实现 05-用户发布的新闻的前后端实现 06-404统一处理界面 第11节 后台管理 07-管理后台功能介绍&amp;管理员账号的添加引入 08-集成创建管理员的函数的到命令行 09-后台管理员登录 10-如果管理员已登录，那么就直接跳到主页 11-修复普通用户能访问管理员页面的BUG 12-添加测试用户 13-人数的总数&amp;月新增数&amp;日新增数 14-用户活跃的折线数据返回 15-后台用户列表的显示 16-待审核的新闻列表数据展示 17-新闻审核列表的搜索功能完成 18-新闻的审核详情显示 第12节 新闻版式编辑 01-点赞bug修复 02-回顾 03-新闻审核实现 04-新闻版式编辑列表界面实现 05-编辑详情页的页面跳转以及引入 06-审核详情的新闻数据加载 07-新闻的编辑提交 第13节 新闻的分类管理 08-新闻分类的数据展示 09-新闻的分类修改和添加 10-新闻详情页作者数据的展示 11-用户的关注和取消关注 12-用户个人中心的关注列表显示 13-其他用户的界面展示 14-其他用户的数据展示 15-其他用户的发布的新闻展示 第14节 项目部署 16-阿里云服务器简单介绍 17-Nginx和Gunicorn的介绍 18-部署helloworld程序 19-部署新经资讯项目到阿里云 20-Nigix转发演示 4-5 Django框架V4.0 第1节 框架简介与工程创建 01_框架细节复习 02_如何学习框架 03_Django框架简介 04_Django框架特点 05_Django环境创建 06_创建Django工程 07_Pycharm使用Django工程 08_创建子应用 第2节 django路由与视图 09_在应用中创建视图定义路由 10_配置文件说明 11_静态文件使用 12_Django解析路由的流程 13_路由定义的顺序 14_路由命名与reverser反推 16_路由定义位置与斜线结尾的说明 17_URL路径表示资源的演示理解 第3节 视图提取请求参数 18_App应用配置 19_前端传递参数的方式 20_URL提取参数 21_QueryDict对象 22_提取查询字符串参数 23_Postman安装使用 02_路由命名与Base_dir说明 03_获取请求体数据 04_获取请求头与其他属性 第4节 django中使用缓存 05_构造响应对象方法 06_django使用缓存 07_本地缓存跨机问题 08_使用django-redis保存session 第5节 django基于类的视图与中间件 09_类视图引入 10_类视图的定义与使用 11_类视图实现的原理 12_在路径中添加装饰器行为 13_在定义类时使用method_decorator添加装饰器 14_装饰器需要进行转换的原因 15_创建扩展类 16_理解扩展类 17_中间件使用 第6节 数据库配置与模型 03_数据库配置 04_Django模型类的定义 05_模型类可以使用的类型与选项 06_数据库表名与迁移 07_模型类的细节说明 08_shell工具与mysql日志 09_添加数据的方法 第7节 模型数据查询与管理器 10_基本查询 11_过滤查询 12_F对象与Q对象 13_聚合排序与关联查询 14_关联查询再次说明 15_数据库修改与删除 16_模型类补充str方法 17_查询集QuerySet 18_模型管理器 第8节 Django模板使用与表单 19_Django使用模板方式 20_Django模板语法 02_模板纠正与每日反馈说明 03_Django使用表单的方法 04_使用表单举例 第9节 Django后台站点管理 05_使用Admin站点的预设值 06_自定义Admin管理器 07_Admin站点列表页控制 08_Admin站点编辑页面控制 09_控制Admin站点的整体标题信息 10_上传图片使用 第10节 认识Resful及DjangoDRF 11_向DjangoRESTframework过渡说明 12_前后端分离介绍 13_什么是RESTful风格 14_RESTful设计方法 15_xml格式说明 16_使用Django定义REST API 03_对于序列化的理解说明 04_了解DjangoRESTframework 05_DRF开发配置 06_见识DRF开发的流程与魅力 第11节 DRF序列化器定义与使用 07_序列化器的定义 08_定义序列化器的字段与选项参数 09_创建序列化对象 10_序列化使用 11_序列化的补充使用 第12节 DRF序列化器验证与模型类序列化 12_调用序列化器进行验证 13_定义序列化器的验证行为 14_保存序列化器的数据 15_保存序列化的补充说明 16_模型类序列化器的定义 17_模型类序列化器的扩展参数 第13节 DRF基于类的视图 18_Request与Response和类图查看 02_DRF框架中json数据汉字乱码问题 03_对DRF类视图的整体认识 04_使用APIView基类 05_使用GenericAPIView基类 06_直接继承GenericAPIView的使用方法 第14节 DRF视图集使用 07_mixin扩展类的使用 08_视图集的使用 09_视图集使用举例 10_视图集中附加action的方法 11_Router路由的定义 第15节 DRF权限配置及自动生成接口 12_认证配置方法 13_权限配置方法 14_限流配置方法 15_过滤配置方法 16_版本号使用配置 17_异常处理使用方法 18_自动生成接口文档方法 4-6 【项目】美多商城V4.0 第1节 项目开发准备 03_项目简介 04_电商的商业模式 05_项目开发的流程 06_后端需要思考设计的技术点 07_项目业务需求说明 08_项目技术架构说明 第2节 项目创建及工程配置 09_项目创建 10_前端静态文件服务器live_server的使用 11_git使用ssh的说明 12_工程配置 13_补充数据库异常处理 第3节 图片验证码 14_用户模型类创建 15_图片验证码的后端编写 16_图片验证码的前端编写 第4节 短信验证码 02_短信验证码序列化器定义 03_关于Pycharm提示的配置与后端也须校验参数的说明 04_短信验证码视图编写 05_补充删除图片验证码与异常说明 06_redis管道pipeline的使用 07_短信验证码前端实现 08_短信验证码测试 第5节 celery异步处理短信任务 09_celery的整体认识 10_celery的程序定义 11_定义使用发送短信验证码异步任务 12_校验用户名与手机号是否存在的接口说明 第6节 用户注册以及jwt验证机制 13_注册接口说明 14_JWT介绍 02_git工具处理换行符和is_valid说明 03_跨域请求与DRF解决 04_配置本机域名 05_在前端文件中使用后端域名 06_关于AllowHost说明与PyCharm对JS的提示修改 07_djangorestframework-jwt使用 08_注册前端保存JWT token 09_为JWT视图补充返回userid和username 第7节 用户登录 10_登录支持用户名和密码的开发思路 11_修改Django认证后端支持用户名和密码 12_登录前端逻辑 第8节 忘记密码与重置密码 13_忘记密码的业务逻辑分析 14_接口访问凭据access_token的引入 15_itsdangerous模块的使用 16_忘记密码第一步获取发送短信验证码凭据的后端接口实现 17_关于从码云拉代码的说明 18_忘记密码第一步的前端实现 19_凭借access_token发送短信验证码的后端实现 20_发送短信的前端代码 21_获取修改密码调用凭据的后端实现 22_获取修改密码调用凭据的前端实现 23_重置密码 第9节 QQ登录-返回登录网址的前后端实现 03_QQ第三方登录业务说明与申请说明 04_使用QQ登录的时序图说明 05_创建QQ登录的模型类 06_关于程序中细节可能导致的错误说明和urllib模块使用方法 07_实现返回QQ登录网址的后端接口 08_获取QQ登录网址的前端实现 第10节 QQ登录-其他操作 09_凭借code获取access_token的实现 10_凭借access_token获取openid的实现 11_根据openid判断用户是否绑定过做不同处理 12_前端向后端传送code请求获取用户身份的编写 13_绑定用户与openid的前后端处理 第11节 用户个人中心业务与邮箱验证 02_用户个人中心业务实现 03_保存邮箱发送验证邮件的业务说明 04_Django发送邮件的方法 05_后端保存邮箱的接口实现 06_定义发送邮件的异步任务 07_生成验证链接并发送邮件及前端编写 08_验证邮箱的业务实现 第12节 收货地址管理 09_创建省市区数据库及编写导入脚本 10_python脚本添加解释器声明的方法 11_省市区视图集的编写 12_省市区添加缓存的方式 13_用户地址模型类说明 第13节 广告页表设计与迁移 02_广告页数据与商品类别数据表设计 03_商品表数据设计 04_广告数据表与商品数据表的迁移 第14节 Docker与Fastdfs 05_FastDFS简介 06_虚拟化与Docker简介 07_Docker的概念 08_Docker安装 09_Docker镜像与容器的使用 10_使用Docker容器运行FastDFS的tracker和storage 11_FastDFS客户端上传图片的使用 12_自定义Django的文件存储系统 第15节 富文本编辑器、页面静态化、定时任务 13_ckeditor富文本编辑器的使用 14_测试与bug解决 02_页面静态化思想 03_首页静态化编写 04_更改Vue变量语法避免与Django模板冲突_退出逻辑 05_crontab定时任务的使用 第16节 异步实现页面静态化 06_编写首页生成静态文件的脚本 07_商品详情页静态化分析 08_商品详情页静态化说明 09_商品详情规格生成逻辑说明 10_商品详情静态化异步任务实现 11_通过模型Admin管理器类的save_model等方法调用静态化异步任务 第17节 热销商品、用户浏览记录、商品列表页功能实现 12_获取热销商品的后端编写 13_DRF使用缓存的详细说明 14_热销商品测试与图片路径问题解决说明 15_用户浏览历史记录redis的设计讲解 16_用户浏览历史记录保存接口编写 17_用户浏览历史记录测试 18_在用户中心查看浏览历史记录编写 01_商品列表商品分类部分静态化处理 02_商品列表后端接口实现 03_商品列表页bug解决 第18节 商品搜索功能能实现 04_测试数据sql修改与数据库迁移文件git追踪 05_搜索引擎原理与elasticsearch介绍 06_docker安装elasticsearch 07_haystack配置 08_创建索引类与生成索引数据 09_创建索引视图与搜索测试 第19节 购物车模块基本实现 10_购物车需求分析与存储数据结构设计 11_pickle模块与base64的使用 12_保存到购物车接口设计与取消视图用户认证说明 13_保存到购物车接口编写 01_查询购物车数据 02_修改数据幂等性说明 03_ubuntu中使用定时任务的解决 第20节 购物车其他功能 04_购物车修改 05_购物车删除 06_合并购物车逻辑1 07合并购物车逻辑2 08修改登录逻辑增加合并购物车 第21节 订单功能基本实现与测试 09_订单数据库表设计 10_订单结算实现 11_关于decimal的说明 12_保存订单的序列化器与视图定义 13_保存订单数据逻辑分析与Django使用事务 14_保存订单数据实现 15_保存订单测试 第22节 订单并发处理 16_并发下单演示与解决办法说明 17_使用乐观锁解决并发 18_修改数据库不从新查询库存的bug 19_数据库事务隔离级别说明 01_下单成功页面 第23节 支付宝支付功能 02_支付宝支付流程演示与支付数据库构建 03_创建支付宝应用流程与沙箱环境介绍 04_支付宝支付流程 05_rsa对数据进行加密签名处理 06_密钥对加密解密纠正说明 07_创建秘钥对与秘钥配置 08_支付宝接口说明与SDK使用 09_请求支付宝支付链接接口实现 10_发起支付宝支付请求测试 11_支付宝重定向返回接口实现 第24节 xadmin后台管理 12_xadmin介绍与安装 13_xadmin基本页面样式控制 14_xadmin保存删除数据补充自定义逻辑实现与用户管理定制 15_权限使用说明 第25节 django项目数据库配置与部署 16_主从同步与读写分离 17_mysq主从同步配置 18_django数据库读写分离路由器实现 19_django数据库路由的补充说明 20_网站服务器架构说明 21_静态文件部署 22_动态服务部署配置 4-7 Shell编程和自动化运维V3.1 第1节 Shell使用入门 000_课程简介+运维(了解) 001_shell快速入门(shell是什么+shell分类) 002_shell快速入门(shell执行方式) 第2节 注释和变量 003_shell基础知识(shell注释) 004_shell基础知识(shell脚本执行) 005_shell基础知识(shell脚本开发规范) 006_shell基础知识(shell本地变量之普通变量三种定义方式) 007_shell基础知识(shell本地变量之命令变量两种定义方式) 008_shell基础知识(shell全局变量查看和两种定义方式) 009_shell基础知识(shell变量四种查看方式和删除变量) 010_shell基础知识(shell内置变量之和文件相关$0) 011_shell基础知识(shell内置变量之和文件相关$n) 012_shell基础知识(shell内置变量之和文件相关$#+$？) 第3节 条件表达式和常用命令 015_shell进阶(两种验证表达式) 016_shell进阶(条件表达式之逻辑) 017_shell进阶(条件表达式之文件) 018_shell进阶(条件表达式之数字+字符串) 019_shell进阶(两种计算表达式) 020_shell进阶(常见符号之重定向+管道符) 021_shell进阶(常见符号之后台执行&amp;) 022_shell进阶(常见符号之信息符号+设备文件) 023_shell进阶(常见命令之grep) 024_shell进阶(常见命令之sed替换) 025_shell进阶(常见命令之sed增加) 026_shell进阶(常见命令之sed删除+其他) 027_shell进阶(常见命令之awk) 028_shell进阶(常见命令之find) 第4节 流程控制和综合练习 029_shell流程控制(单分支if语句) 030_shell流程控制(双分支if语句+多分支if语句) 031_shell流程控制(多分支if语句生产案例) 032_shell流程控制(case语句) 033_shell流程控制(for语句) 034_shell流程控制(while语句) 035_shell流程控制(until语句) 036_shell流程控制(简单函数定义和调用) 037_shell流程控制(传参函数定义和调用+脚本传参函数调用) 038_shell第一阶段(综合演练之需求分析) 039_shell第一阶段(综合演练之脚本编写) 第5节 代码发布 040_代码发布(代码发布简介) 041_代码发布(代码发布方式) 042_代码发布(代码发布流程简介) 043_代码发布(代码发布流程详解) 044_代码发布(技术关键点之压缩与解压缩) 045_代码发布(技术关键点之文件传输) 046_代码发布(技术关键点之文件备份) 047_代码发布(技术关键点之文件备份) 第6节 环境部署 048_环境部署(基础目录环境) 049_环境部署(主机网络环境分析) 050_环境部署(主机网络环境配置) 051_环境部署(需求分析和方案定制) 052_环境部署(python虚拟环境) 053_环境部署(django软件安装+python类型软件安装流程) 054_环境部署(django环境部署) 055_环境部署(pcre软件安装) 056_环境部署(nginx软件安装) 057_环境部署(nginx基本操作+常见报错分析) 058_环境部署(nginx代理django配置及测试) 第7节 手工代码发布和脚本代码发布 059_手工代码发布(方案分析) 060_手工代码发布(方案实施) 061_脚本代码发布(简单脚本之命令罗列) 062_脚本代码发布(简单脚本之固定内容变量化) 063_脚本代码发布(简单脚本之功能函数化) 064_脚本代码发布(简单脚本之远程执行) 065_脚本代码发布(大型脚本之脚本框架) 066_脚本代码发布(大型脚本之命令填充) 067_脚本代码发布(大型脚本之日志功能) 068_脚本代码发布(大型脚本之增加锁文件) 069_脚本代码发布(大型脚本之流程主函数) 070_脚本代码发布(大型脚本之脚本参数安全) 071_脚本代码发布(大型脚本之脚本调试) 072_脚本代码发布(总结) 4-8 数据结构和算法V1.0 第1节 时间复杂度 01_算法引入 02_时间复杂度与大O表示法 03_最坏时间复杂度与计算规则 04_常见时间复杂度与大小关系 05_代码执行时间测量模块timeit 06_Python列表类型不同操作的时间效率 07_Python列表与字典操作的时间复杂度 第2节 顺序表 08_数据结构引入 09_内存、类型本质、连续存储 10_基本顺序表与元素外围顺序表 11_顺序表的一体式结构与分离式结构 12_顺序表数据区替换与扩充 13_顺序表添加与删除元素Python列表的实现 第3节 单链表 14链表的提出 15_单链表的ADT模型 16_Python中变量标识的本质 17_单链表及结点的定义代码 18_单链表的判空、长度、遍历与尾部添加结点的代码实现 01_单链表尾部添加和在指定位置添加 02_单链表查找和删除元素 03_单链表与顺序表的对比 第4节 双向链表和单向链表 04_双向链表及添加元素 05_双向链表删除元素 06_单向循环链表遍历和求长度 07_单向循环链表添加元素 08_单向循环链表删除元素 09_单向循环链表删除元素复习及链表扩展 第5节 栈和队列 10_栈与队列的概念 11_栈的实现 12_队列与双端队列的实现 第6节 冒泡排序和插入排序 13_排序算法的稳定性 14_冒泡排序算及实现 15_选择排序算法及实现 16_插入算法 01_插入排序1 02_插入排序2 第7节 希尔排序和快速排序 03_希尔排序 04_希尔排序实现 05_快速排序 06_快速排序实现1 07_快速排序实现2 第8节 归并排序和二分查找 08_归并排序 09_归并排序代码执行流程 10归并排序时间复杂度及排序算法复杂度对比 11_二分查找 12_二分查找时间复杂度 第9节 树和二叉树 13_树的概念 14_二叉树的概念 15_二叉树的广度优先遍历 16_二叉树的实现 17_二叉树的先序、中序、后序遍历 18_二叉树由遍历确定一棵树 阶段5 : 爬虫开发 5-1 通用爬虫模块使用V4.0 第1节 爬虫基本概念 day01-01爬虫的概念和爬虫的作用 day01-02爬虫的分类和聚焦爬虫的流程 day01-03搜索引擎的介绍 day01-04http的概念 day01-05浏览器发送请求的流程和url地址的形式 day01-06http的请求形式和get请求post的区别和状态码 day01-07字符串的复习 第2节 requests处理GET、POST请求 day01-08requests模块发送请求和获取html字符串的方法 day02-02发送带header的请求 day02-03发送带cookie的请求 day02-04贴吧爬实现方法1 day02-05贴吧怕长实现方法2 day02-06发送post请求 day02-07百度翻译实现 第3节 requests处理代理、cookie、session day02-08代理ip的使用 day02-09代理使用的注意点 day02-10session类的使用 day03-03requests处理cookie day03-04寻找登录的地址 day03-05js的分析流程 day03-06requests获取cookie和处理ssl证书错误 day03-07超时参数和retrying 第4节 数据提取-json、正则 day04-08chrome的使用介绍 day04-09数据的提取的介绍 day04-10json模块的学习01 day04-11json模块的学习02 day04-13 36kr爬虫 day04-02豆瓣爬虫 day04-03正则的语法 day04-04re模块的使用 day04-05果壳网分析 day04-06果壳代码实现 第5节 数据提取-xpath、lxml day04-07xpath和xml的了解 day04-08xpath语法学习01 day04-09xpath语法学习02 day04-10xoath语法的学习03 day04-11lxml模块的学习 day05-02贴吧爬虫01 day05-03贴吧爬虫02 day05-04糗百爬虫分析 day05-05糗百爬虫实现 第6节 多任务爬虫爬虫与selenium day05-06多线程爬虫知识点 day05-07多线程糗百 day05-08多进程糗百 day05-09线程池糗百 day05-10协程池爬虫 day05-12常见反扒分析 day06-02selenium的介绍 day06-03selenium的入门使用 day06-04selenium模拟登陆豆瓣 day06-05selenium定位元素 day06-06斗鱼爬虫 day06-08打码平台的使用 5-2 MongoDB数据库V4.0 第1节 Mongo的基本使用 day06-09nosql的介绍 day06-10mognodb的安装和启动 day06-11mongodb 的数据库和集合 day06-12mongodb 的增删改查 day07-03mongodb的运算符 day07-04正则和skip和limit day07-05mongodb的投影和排序 day07-06mongdb的统计个数和去重 第2节 Mongo的高级使用 day07-07mongdb的介绍和$group管道命令 day07-08mongodb的索$match和$project day07-09mongodb的索$sort,$limit和$skip day07-10mongodb的索引的创建查看和唯一索引 day07-11mongodb的索引的删除和复合索引 day07-12mogndb的备份和恢复 day07-13豆瓣电视数据的练习 day07-14pymongo的学习 5-3 【项目】电商爬虫和Scrapy框架V4.0 第1节 scrapy框架的基本使用 day08-02scrapy框架的认识 day08-03scrapy框架的流程 day08-04scrapy框架的模块 day08-05scrapy框架的流程 day08-06scrapy的pipeline day08-07scrapy实现翻页请求和腾讯招聘爬虫 day08-08scrapy构造请求的更多参数 第2节 scrapy框架其他知识学习 day08-09Item定义使用的方法和阳关政务平台爬虫 day09-02果壳爬虫 day09-03scrapy debug的信息认识 day09-04scrapy shell的使用 day09-05 scrapy settings文件的学习 day09-06scrapy open_spider和close_spider的认识 第3节 苏宁图书爬虫案例 day09-07苏宁图书爬虫01 day09-08苏宁图书爬虫02 day10-02苏宁图书爬虫 第4节 scrawlspider以及scrapy模拟登录 day10-03crwalspider爬虫的认识 day10-04腾讯招crwalspider完成 day10-05crawlspider注意点 day10-06腾讯招聘crawlspdier爬虫 day10-07下载器中间件的使用 day10-08scrapy模拟登陆之携带cookie day10-09scrapy模拟登陆之发送post请求 day10-10scrapy模拟登陆之表单提交 day11-02苏宁爬虫 第5节 分布式scrapy_redis学习及京东爬虫 day11-03scrapy的概念和流程 day11-04redis的简单复习 day11-05scrapy_redis中dmoz的执行现象 day11-06scrapyredis中生成指纹和redispipeline的原理 day11-07scrapy_redis中的request入队的条件 day11-08scrapy的入队和指纹分析 day11-09jd爬虫 第6节 redisspider及当当爬虫 day12-02redisspider的介绍 day12-03当当爬虫01 day12-04当当爬虫02 day12-05当当爬虫演示和pycharm发布代码的功能 第7节 rediscrawlspdier及亚马逊爬虫 day12-06rediscrawlspider的爬虫介绍 day12-07亚马逊爬虫01 day12-08亚马逊爬虫02 day12-09crontab的学习 5-4 爬虫框架开发V4.0 第1节 爬虫框架开发分析 day13-02框架的了解 day13-03框架的设计思路 day13-04框架的运行现象演示 day13-05框架的雏形代码结构 第2节 框架雏形搭建 day13-05框架的雏形代码结构 day13-06http和item对象的封装 day13-07调度器，下载器，spider的封装 day13-08管道和引擎的封装 day13-09框架的安装 day13-10运行框架 day13-11中间件的封装和使用 第3节 框架完善之日志、xpath、多爬虫实现 day13-12日志的使用 day13-13配置文件的实现 day14-02项目文件件下实现爬虫 day14-03爬虫中实现发送多个请求 day14-04response对象添加xpath等方法 day14-05糗百爬虫 day14-06实现多个解析函数 day14-07实现多个爬虫01 day14-08实现过个爬虫02 第4节 框架完善之管道、请求去重、异步任务实现 day14-09实现过个管道 day14-10实现过个中间件 day14-11模块动态导入的方法 day14-12模块动态导入的实现 day15-02请求去重实现 day15-03使用线程池分析 day15-04线程池和协程池使用的实现 第5节 框架升级分布式、增量、断续爬的实现 day15-05分布式的实现 day15-06分布式是的实现值结束的条件 day15-07实现请求去重的关闭 day15-08请求备份的分析 day15-09charles的使用介绍 阶段6 : 人工智能 6-1 数据挖掘V4.0 第1节 matplotlib绘制折线图 01_课程介绍 02_数据挖掘课基础课程定位以及目标 03_jupyter使用于安装 04_matplotlib的绘图架构 05_温度的简单显示 06_案例：城市温度显示-刻度、中文 07_案例：城市温度显示-横纵坐标标签、标题、图例 08_案例：城市温度显示-多个坐标系 09_折线图的应用场景以及总结 第2节 matplotlib绘制基本统计图 10_电影票房对比：柱状图 11_柱状图的应用场景 12_案例：电影市场分布：直方图 13_案例：电影排片占比：饼图绘制 14_其它功能了解，总结以及作业 01_作业讲解 第3节 numpy基础 02_每日目标、numpy介绍优势 03_array的基本属性 04_数组形状理解、自定义数据类型 05_数组的创建 06_正态分布理解 第4节 案例:股票数据处理 07_案例：股票涨跌幅数据创建 08_案例：股票数据的形状、类型、转换 09_案例：股票数据的逻辑运算和统计运算 第5节 数组运算分割合并 10_数组的运算讲解、矩阵与数组的区别 11_数组的分割与合并 12_总结 第6节 pandas索引切片排序 01_作业与复习 02_pandas的数据结构 02_pandas的索引修改操作 03_series结构 04_pandas切片操作与排序 第7节 pandas统计计算和文件读取 05_pandas统计运算 06_案例：股票涨跌幅累计计算 07_逻辑与算数运算 08_pandas的文件读取 09_案例：pandas的缺失值处理 10_案例：股票涨跌幅的离散化处理 11_总结 第8节 pandas合并交叉表分组聚合 01_pandas的哑变量矩阵合并 02_合并 03_交叉表与透视表 04_交叉表与透视表 05_分组与聚合 第9节 股票数据基本知识 06_金融市场基础知识 07_股票的基础知识 08_股票数据组成 09_股票数据重采样 10_除权数据介绍总结 第10节 时间序列和股票数据处理 01_复习 02_pandas时间序列分析 03_pandas时间操作 04_pandas生成时间序列 05_移动平均线之SMA 06_加权移动平均线与指数平滑移动平均线 07_移动方差和标准差 08_相关系数与散点图绘制分析结果 09_平均线数据的保存 第11节 股票数据分析 02_投资技术的两种方法 03_双均线策略以及MACD介绍 04_MACD结果绘图 05_编写MACD交易策略 06_RSI指标分析以及结合MACD指标策略 07_策略回测过程 08_模拟交易过程 09_模拟交易总结 10_总结 6-2 机器学习V4.0 第1节 机器学习介绍和特征提取 01_机器学习介绍 02_特征工程介绍工具介绍 03_特征抽取之字典数据特征抽取 04_字典特征抽取的结果分析 05_文本特征抽取 06_文本特征抽取结果分析 07_中文的文本特征抽取 08_TFIDF介绍 09_TFIDF结果分析 第2节 特征预处理和数据降维 10_特征预处理之归一化 11_案例：约会对象数据归一化标准化对比处理以及分析 12_特征降维-特征选择之方差选择法 13_特征降维-特征选择之相关性分析 14_主成分分析PCA 15_用户物品类别案例介绍 16_案例与特征降维总结 第3节 机器学习算法介绍和K-近邻算法 17_机器学习算法介绍 18_机器学习开发流程 01_复习 02_数据集划分 03_转换器与估计器 04_估计器流程介绍 05_K-近邻算法原理 06_案例：FB业务类型预测 07_K-近邻算法总结 08_案例：FB业务类型预测的K值超参数调优 第4节 朴素贝叶斯和决策树算法 09_朴素贝叶斯算法原理 10_案例：20类新闻分类 11_朴素贝叶斯算法总结 12_决策树分类原理 13_泰坦尼克号数据介绍 14_案例：泰坦尼克号生存分类预测 15_决策树总结 第5节 随机森林和线性回归算法 16_随机森林原理 17_案例：随机森立案例，超参数调优 18_随机森林总结 01_复习 02_线性回归原理 03_案例：房价数据预测-线性回归的正规方程、梯度下降方式结果 04_线性回归总结 05_线性回归拟合非线性关系数据容易出现问题过拟合 06_解决办法-正则化 第6节 逻辑回归算法和模型保存 07_逻辑回归原理 08_案例：逻辑回归癌症预测 09_样本不均衡评估标准AUC指标 10_模型保存于加载 11_聚类原理记忆案例 12_三天算法总结 6-3 【项目】量化交易V4.0 第1节 量化交易框架入门 01_量化交易介绍 02_量化交易项目流程、做什么 03_回测框架介绍 04_策略运行过程介绍 05_策略运行过程介绍2 06_获取板块等、交易行情数据 07_获取财务数据与定时器 第2节 交易策略入门 07_获取财务数据与定时器 08_投资组合与交易 09_策略的收益指标 10_策略风险指标 11_案例：介绍 12_案例：实现简单的一个选股策略 13_总结 01_复习 第3节 多因子法和去极值 02_alpha与beta和多因子策略介绍 03_案例：多因子的市值因子选股介绍 04_案例：多因子的市值因子选股演示 05_多因子策略流程、因子数据组成、去极值介绍 06_案例：分位数去极值与3倍中位数法去极值 07_案例：3sigma法去极值 第4节 因子数据处理 08_因子数据的标准化处理 09_市值中性化处理介绍 10_案例：市值中性化实现以及回测选股结果 11_市值中性化结果总结分析 12_总结 01_复习 第5节 IC分析实战 02_单因子有效性分析介绍 03_案例：因子暴露度与收益率相关性计算演示 04_IC分析实战：alphalens介绍、因子横截面数据准备 05_IC分析实战：价格时间获取、alphalens生成统一数据结构 06_IC分析实战：IC结果统计与研报分析阅读 第6节 多因子分析 07_收益率分析实战：单因子有效性打分筛选规则与单因子回测框架查看选股位置 08_分组因子筛选 09_分组统计结果讲解以及研报分析阅读 10_多因子相关性实战：计算相关性以及目的 11_多因子合成实战：PCA进行因子暴露值合成 01_复习 02_回测内容确定 第7节 打分法选股 03_打分法选股实战：分组打分 04_打分法选股实战：综合得分选股股票池(factor拼写错误) 05_打分法选股实战：回测结果分析 第8节 回归法选股 06_回归法选股实战：回归系数确定-每月末交易列表获取、因子数据获取 07_回归法选股实战：股票交易日列表价格数据获取、下一期收益率计算 08_回归法选股实战：股票因子特征值和股票下期收益率回归训练 09_回归法选股实战：回归系数确定步骤总结 10_模拟交易介绍(在3点半交易时间内，先介绍) 11_回归法选股实战：第二步利用回归系数选股-回测因子数据处理 12_回归法选股实战：第二步利用回归系数选股-回归计算预测股票收益率结果分析 13_两种选股方法总结 第9节 量化交易系统架构 14_技术指标策略实践(了解) 15_量化系统架构介绍 16_量化总结 6-4 深度学习V4.0 第1节 TensorFlow基础知识 01_深度学习和TensorFlow介绍 02_Tensorflow程序结构组成 03_图与OP介绍、Tensorboard显示 04_OP名字 05_会话介绍 06_张量介绍、静态形状和动态形状 07_创建变量OP、初始化变量、修改变量值 08_命名空间与共享变量 第2节 回归训练案例 09_实现回归训练案例：线性回归复习以及步骤分析 10_实现回归训练案例：准备数据、建立模型、计算损失、GD优化步骤实现 11_实现回归训练案例：会话运行训练 12_实现回归训练案例：学习率与步长、梯度爆炸 13_实现回归训练案例：trainable参数问题、张量值的Tensorboard跟踪显示 14_实现回归训练案例：线性回归模型保存、加载、命令行参数 15_总结 第3节 TensorFlow文件读写 01_文件读取流程介绍、狗图片数据读取案例 02_开启线程批处理读取 03_狗图片读取总结 04_cifar二进制数据读取案例 05_案例：写入TFRecords文件 06_案例：读取TFRecords文件 第4节 神经网络和MNIST手写数字识别 07_神经网络基础介绍 08_神经网络的分类原理损失、优化 09_神经网络原理总结 10_Mnist手写数字识别：分析、网络结构定义 11_Mnist手写数字识别：循环步数训练 12_Mnist手写数字识别：增加准确率 13_Mnist手写数字识别：增加模型张量值观察tensorboard 14_Mnist手写数字识别：训练好的模型进行预测测试 15_线性神经网络的局限性-改进方式激活函数、改变网络结构 01_复习 第5节 卷积神经网络 02_卷积神经网络介绍 03_卷积网络-卷积原理分析 04_卷机网络-卷积总结 05_卷机网络-激活函数介绍 06_卷机网络-池化层分析、总结 第6节 CNN卷积网络识别MNIST数据 07_CNN卷机网络识别Mnist：设计网络结构分析 08_CNN卷机网络识别Mnist：模型代码编写 09_CNN卷机网络识别Mnist：优化训练代码、蓄念运行 10_CNN卷机网络识别Mnist：网络改进和优化 11_卷积神经网络拓展介绍 第7节 验证码识别 12_验证码识别实战：验证码项目介绍、原理分析 13_验证码识别实战：数据处理成TFRecords文件介绍 14_验证码识别实战：验证码TFRecords数据读取 15_验证码识别实战：网络代码实现、训练 16_验证码识别实战：准确率计算实现 17_总结]]></content>
  </entry>
  <entry>
    <title><![CDATA[某马(hm)Java57期全套2019已更新 ☆☆☆顶☆☆☆]]></title>
    <url>%2F2019%2F12%2F01%2F005%E6%9F%90%E9%A9%ACjava57%E6%9C%9F%E5%85%A8%E5%A5%97%E5%B7%B2%E5%85%A8%E9%83%A8%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[全套33元！！！在文章底部扫码付款后可获取密码，然后回到主页紧接下一个文章提取百度网盘网盘，有问题可私聊qq：40901161601 java_基础入门02 Java_基础进阶03 Java_Web04 旅游网项目05 Mybatis06- pring07 Spring_MVC08 Oracle09 Maven项目管理工具10 企业权限管理系统11 乐优商城(2019已更新完整版)12 Lucene13 ELK 201903更新14 Spring Data JPA15 Spring Boot16 Git17 Vue18 网络爬虫19 Docker容器化20 持续集成与容器管理21 微服务教育网学成在线22 华为 ServiceComb微服务框架23 容器化进阶K8S24 华为云Paas服务治理25 框架架构高级26 传统行业SaaS解决方案27 好客租房28 全新版十次方29 大数据转型-Hadoop330 青桔商城完整版]]></content>
  </entry>
  <entry>
    <title><![CDATA[人工智能]]></title>
    <url>%2F2019%2F11%2F29%2F2016-07-07-iOSMachineLearning_TensorFlow%2F</url>
    <content type="text"><![CDATA[人工智能、机器学习都已走进了我们的日常，尤其是愈演愈热的大数据更是跟我们的生活息息相关，做 人工智能、数据挖掘的人在其他人眼中感觉是很高大上的，总有一种遥不可及的感觉，在我司也经常会听到数据科学部的同事们提到 机器学习、数据挖掘 之类的词。但这些名词真的跟我们移动开发就没直接关系了吗？ 作为移动开发者来说，无时无刻不被这些名词狠狠地敲打着脆弱的内心。💢 💢 💢 何时才能够将机器学习、深度学习应用在移动端，敲响移动端机器学习工业化的大门呢？ 想象一下，某一天你身处一个完全陌生的环境，周围都是陌生的事物，而运行在iPhone的某个APP却对这个环境了如指掌，你要做的就是打开这个APP，输入你需要了解的事物，iPhone告诉你这个事物的信息，你也就没有了陌生事物了。世界就在眼前！ 如下图： 上面物体的识别准确率还是蛮不错的，基本识别出了键盘（49%的概率）、鼠标（46%的概率）和水杯（24%的概率）。 但是在某些事物的识别准确度方便却差强人意，比如下图： iPhone 6被识别成了iPod（59%的概率），而iPod的却是不怎么敢认（10%的概率）。想想最崩溃的估计是iPhone 6了，身价直接被降了好几个等级。 上面的例子来自于TensorFlow官方iOSDemo，暂且不评述TensorFlow的识别准确度如何，毕竟它还年轻，但是仅凭其识别能力的体现，也给机器学习在移动端的运用带来了无限的可能。 一、TensorFlow（简称TF） 去年，Google资深系统专家Jeff Dean在湾区机器学习大会上隆重介绍了其第二代深度学习系统TensorFlow，一时间网络上针对TensorFlow的文章铺天盖地，揭秘TensorFlow：Google开源到底开的是什么？、Google开源TensorFlow系统，这背后都有什么门道？、如何评价Google发布的第二代深度学习系统TensorFlow?等等文章，TensorFlow的燎原之火一直在燃烧蔓延着，其GitHub上的开源库在此文撰写时，也已经被star：27550，fork：11054了。🔥 🔥 🔥 🔥 🔥 不负众望，Google一直宣称平台移植性非常好的TensorFlow，终于在2016年6月27日，发布0.9版本，宣布移动端支持。TensorFlow v0.9 now available with improved mobile support( 有墙💢 )，同时也给出了移动端的Demo，对于代码为生的程序员，身处大数据处理为主导的TalkingData，也小试身手了一把，下载TensorFlow源码，查看编译指南，开始跳坑、填坑之路，也成就了此篇拙文的产生。 二、从TensorFlow到iOS静态库对于iOS平台下如何使用TensorFlow，TensorFlow给出了详细的编译脚本命令，详情请查看官方文档的命令。 第一步. 工具准备工欲善其事必先利其器，在开始编译工作之前，需要准备一些编译所必须的工具： Homebrew: Mac os x 上包管理工具，具体使用方法可参考Doc。 1$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; Homebrew安装好之后，依次安装三个辅助性编译工具： 123$ brew install libtool $ brew install autoconf $ brew install automake 三个工具的含义，请参考：https://en.wikipedia.org/wiki/GNU_Libtool 第二步. 克隆TensorFlowGoogle以Apache 2.0开源协议将TensorFlow开源在GitHub上，我们可以直接使用TensorFlow源码。 在任意你想存放TensorFlow源码的地方（建议不要放在桌面。^_^），clone项目。 1$ git clone https://github.com/tensorflow/tensorflow 第三步. 编译前准备 在TensorFlow的tensorflow/contrib/makefile/目录下，有很多可使用的编译脚本，其中build_all_ios.sh脚本专门用来一键编译TensorFlow iOS静态库。虽然可以直接使用此脚本进行一键编译，但是因为有墙，某些依赖需要提前做处理。 下载protobuf protobuf 是编译前唯一需要特殊处理的依赖库，点击下载，下载protobuf之后，解压，备用。 下载googlemock 虽然protobuf编译脚本autogen.sh中的googlemock链接地址https://googlemock.googlecode.com/files/gmock-1.7.0.zip无法直接下载到，但是细心的人会发现，在浏览器中输入https://googlemock.googlecode.com/地址后，会跳转到https://github.com/google/googlemock地址，google在GiHub上的仓库地址。而GitHub上的仓库，我们可以直接的下载，克隆等。 我们直接在GitHub上下载googlemock(点击下载)，下载完成后，修改压缩包名字为gmock-1.7.0.zip，修改后将此压缩包移至上一步protobuf文件夹目录下，备用。 修改下载依赖脚本，移除protobuf的下载 在tensorflow/contrib/makefile/目录下，download_dependencies.sh脚本用来下载相关依赖，打开此脚本文件，注释掉或者直接删掉git clone https://github.com/google/protobuf.git ${DOWNLOADS_DIR}/protobuf部分，目的是不让脚本去下载protobuf。 上面三步准备好后，接下来就进入静态库编译了。 第四步. 一键编译 前面已经知道在TensorFlow文件夹tensorflow/contrib/makefile/目录下的build_all_ios.sh脚本是用来编译iOS静态库的脚本，因此可以直接执行此脚本，开始静态库的编译工作了。 但是有一个问题大家可能会发现，由于编译TensorFlow需要用到protobuf，但是protobuf使我们自己手动下载的，该怎么让手动下载的protobuf能够直接让build_all_ios.sh脚本使用呢？ 答案是复制、粘贴。可能有些low，但是有效。执行命令 build_all_ios.sh之后，立即把之前手动下载的protobuf文件夹拷贝进tensorflow/contrib/makefile/downloads目录。（放心，你拷贝的速度会很快，不会影响编译的执行的。^_^） 1$ build_all_ios.sh 一切准备就绪，接下来就是静静的等待编译完成了。在Mac编译的过程中，建议插上电源，最好不要让设备休眠断电，也最好不要去干别的东西，出去溜达一圈，回来后就看到战果了。 编译完成之后，会在tensorflow/contrib/makefile/gen/目录下看到编译的结果，关于这些静态库该如何使用，自己的项目如何应用，请参考TensorFlow iOS Examples。 三、遇到的问题1、googlecode.com被墙了，需要翻墙！（目前测试挂了VPN也没用），这也是上面编译前准备为什么要那么做的原因。 1curl: (7) Failed to connect to googlemock.googlecode.com port 443: Operation timed out 解决： 请参考 『第三步. 编译前准备』。 2、没有Xcode。 1234xcrun: error: SDK &quot;iphoneos&quot; cannot be locatedxcrun: error: SDK &quot;iphoneos&quot; cannot be locatedxcrun: error: unable to lookup item &apos;PlatformPath&apos; in SDK &apos;iphoneos&apos;+ IPHONEOS_PLATFORM= 解决：安装Xcode，从上面报错的命令中可以看到，在编译静态库的过程中使用了xcrun，而此命令是xCode本身具有的能力。 3、你的Xcode版本不是7.3或以后，或者你有多个Xcode，而默认的安装路径版本不是7.3或以后。 `error: Xcode 7.3.0 or later is required. exit 1`/ 解决：更新Xcode至最新版本，并且保证默认路径下是最新/版本。 如果Xcode是7.3，并且没有条件更新Xcode，你可以修改tensorflow/contrib/makefile/compile_ios_tensorflow.sh 里的REQUIRED_XCODE_VERSION=7.3.0，为REQUIRED_XCODE_VERSION=7.3。（这样修改，目前还不确定会不会带来一些其他影响，最好是升级你的Xcode） 四、参考链接 TensorFlow 中文社区 TensorFlow for Mobile Caffe、TensorFlow、MXnet三个开源库对比 如何评价Tensorflow和其它深度学习系统 深度学习框架大战正在进行，谁将夺取“深度学习工业标准”的荣耀？]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F11%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server 1assadmnbsmandb More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019下密押卷已出，速取]]></title>
    <url>%2F2019%2F10%2F30%2F002%E6%95%99%E5%B8%88%E8%B5%84%E6%A0%BC%E8%AF%81%E5%BF%85%E8%BF%87%2F</url>
    <content type="text"><![CDATA[不要担心距离教资考试还有几天，找我就对了！！1、资源来之不易，重要程度可想而知2、基础知识掌握后，请认真作答该套密卷3、中小学都有4、拿到资料后，大家不要再迷失方向，胡乱找资料，看网课，这些都没用，只会耽误时间！！！抓紧时机看我的资料 保证没问题！！！5、最后，我祝愿大家能够考出一个好成绩！6、如有问题可以问我，我为大家排忧解难！！！我与大家同在！！！（企鹅及时联系）8、qq:409011616]]></content>
      <categories>
        <category>考试</category>
      </categories>
      <tags>
        <tag>教师资格证考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普通话通关资料]]></title>
    <url>%2F2019%2F10%2F28%2F000%E6%99%AE%E9%80%9A%E8%AF%9D%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[链接：https://pan.baidu.com/s/1......................................................................................出现bug,如果已经付款，请咨询qq409011616.............................................链接：https://pan.baidu.com/s/1lcd.............bug...........提取码：隐藏,付款20元后请联系qq:409011616]]></content>
  </entry>
  <entry>
    <title><![CDATA[Color]]></title>
    <url>%2F2018%2F09%2F24%2FColor%2F</url>
    <content type="text"><![CDATA[Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。但是它本身是不支持修改字体、字号与颜色等功能的！ CSDN-markdown编辑器是其衍生版本，扩展了Markdown的功能（如表格、脚注、内嵌HTML等等）！对，就是内嵌HTML，接下来要讲的功能就需要使用内嵌HTML的方法来实现。字体、字号与颜色&lt;font face=“黑体”&gt;我是黑体字&lt;/font&gt;&lt;font face=“微软雅黑”&gt;我是微软雅黑&lt;/font&gt;&lt;font face=“STCAIYUN”&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=7 face=“黑体”&gt;color=#0099ff size=72 face=”黑体”&lt;/font&gt;&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;&lt;font color=gray size=72&gt;color=gray&lt;/font&gt;123456Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3。呈现效果我是黑体字 我是微软雅黑 我是华文彩云 color=#0099ff size=72 face=”黑体” color=#00ffff 可以用十六位颜色值 color=gray 也可以用已知颜色名颜色名列表颜色名十六进制颜色值颜色AliceBlue#F0F8FFrgb(240, 248, 255)AntiqueWhite#FAEBD7rgb(250, 235, 215)Aqua#00FFFFrgb(0, 255, 255)Aquamarine#7FFFD4rgb(127, 255, 212)Azure#F0FFFFrgb(240, 255, 255)Beige#F5F5DCrgb(245, 245, 220)Bisque#FFE4C4rgb(255, 228, 196)Black#000000rgb(0, 0, 0)BlanchedAlmond#FFEBCDrgb(255, 235, 205)Blue#0000FFrgb(0, 0, 255)BlueViolet#8A2BE2rgb(138, 43, 226)Brown#A52A2Argb(165, 42, 42)BurlyWood#DEB887rgb(222, 184, 135)CadetBlue#5F9EA0rgb(95, 158, 160)Chartreuse#7FFF00rgb(127, 255, 0)Chocolate#D2691Ergb(210, 105, 30)Coral#FF7F50rgb(255, 127, 80)CornflowerBlue#6495EDrgb(100, 149, 237)Cornsilk#FFF8DCrgb(255, 248, 220)Crimson#DC143Crgb(220, 20, 60)Cyan#00FFFFrgb(0, 255, 255)DarkBlue#00008Brgb(0, 0, 139)DarkCyan#008B8Brgb(0, 139, 139)DarkGoldenRod#B8860Brgb(184, 134, 11)DarkGray#A9A9A9rgb(169, 169, 169)DarkGreen#006400rgb(0, 100, 0)DarkKhaki#BDB76Brgb(189, 183, 107)DarkMagenta#8B008Brgb(139, 0, 139)DarkOliveGreen#556B2Frgb(85, 107, 47)Darkorange#FF8C00rgb(255, 140, 0)DarkOrchid#9932CCrgb(153, 50, 204)DarkRed#8B0000rgb(139, 0, 0)DarkSalmon#E9967Argb(233, 150, 122)DarkSeaGreen#8FBC8Frgb(143, 188, 143)DarkSlateBlue#483D8Brgb(72, 61, 139)DarkSlateGray#2F4F4Frgb(47, 79, 79)DarkTurquoise#00CED1rgb(0, 206, 209)DarkViolet#9400D3rgb(148, 0, 211)DeepPink#FF1493rgb(255, 20, 147)DeepSkyBlue#00BFFFrgb(0, 191, 255)DimGray#696969rgb(105, 105, 105)DodgerBlue#1E90FFrgb(30, 144, 255)Feldspar#D19275rgb(209, 146, 117)FireBrick#B22222rgb(178, 34, 34)FloralWhite#FFFAF0rgb(255, 250, 240)ForestGreen#228B22rgb(34, 139, 34)Fuchsia#FF00FFrgb(255, 0, 255)Gainsboro#DCDCDCrgb(220, 220, 220)GhostWhite#F8F8FFrgb(248, 248, 255)Gold#FFD700rgb(255, 215, 0)GoldenRod#DAA520rgb(218, 165, 32)Gray#808080rgb(128, 128, 128)Green#008000rgb(0, 128, 0)GreenYellow#ADFF2Frgb(173, 255, 47)HoneyDew#F0FFF0rgb(240, 255, 240)HotPink#FF69B4rgb(255, 105, 180)IndianRed#CD5C5Crgb(205, 92, 92)Indigo#4B0082rgb(75, 0, 130)Ivory#FFFFF0rgb(255, 255, 240)Khaki#F0E68Crgb(240, 230, 140)Lavender#E6E6FArgb(230, 230, 250)LavenderBlush#FFF0F5rgb(255, 240, 245)LawnGreen#7CFC00rgb(124, 252, 0)LemonChiffon#FFFACDrgb(255, 250, 205)LightBlue#ADD8E6rgb(173, 216, 230)LightCoral#F08080rgb(240, 128, 128)LightCyan#E0FFFFrgb(224, 255, 255)LightGoldenRodYellow#FAFAD2rgb(250, 250, 210)LightGrey#D3D3D3rgb(211, 211, 211)LightGreen#90EE90rgb(144, 238, 144)LightPink#FFB6C1rgb(255, 182, 193)LightSalmon#FFA07Argb(255, 160, 122)LightSeaGreen#20B2AArgb(32, 178, 170)LightSkyBlue#87CEFArgb(135, 206, 250)LightSlateBlue#8470FFrgb(132, 112, 255)LightSlateGray#778899rgb(119, 136, 153)LightSteelBlue#B0C4DErgb(176, 196, 222)LightYellow#FFFFE0rgb(255, 255, 224)Lime#00FF00rgb(0, 255, 0)LimeGreen#32CD32rgb(50, 205, 50)Linen#FAF0E6rgb(250, 240, 230)Magenta#FF00FFrgb(255, 0, 255)Maroon#800000rgb(128, 0, 0)MediumAquaMarine#66CDAArgb(102, 205, 170)MediumBlue#0000CDrgb(0, 0, 205)MediumOrchid#BA55D3rgb(186, 85, 211)MediumPurple#9370D8rgb(147, 112, 216)MediumSeaGreen#3CB371rgb(60, 179, 113)MediumSlateBlue#7B68EErgb(123, 104, 238)MediumSpringGreen#00FA9Argb(0, 250, 154)MediumTurquoise#48D1CCrgb(72, 209, 204)MediumVioletRed#C71585rgb(199, 21, 133)MidnightBlue#191970rgb(25, 25, 112)MintCream#F5FFFArgb(245, 255, 250)MistyRose#FFE4E1rgb(255, 228, 225)Moccasin#FFE4B5rgb(255, 228, 181)NavajoWhite#FFDEADrgb(255, 222, 173)Navy#000080rgb(0, 0, 128)OldLace#FDF5E6rgb(253, 245, 230)Olive#808000rgb(128, 128, 0)OliveDrab#6B8E23rgb(107, 142, 35)Orange#FFA500rgb(255, 165, 0)OrangeRed#FF4500rgb(255, 69, 0)Orchid#DA70D6rgb(218, 112, 214)PaleGoldenRod#EEE8AArgb(238, 232, 170)PaleGreen#98FB98rgb(152, 251, 152)PaleTurquoise#AFEEEErgb(175, 238, 238)PaleVioletRed#D87093rgb(216, 112, 147)PapayaWhip#FFEFD5rgb(255, 239, 213)PeachPuff#FFDAB9rgb(255, 218, 185)Peru#CD853Frgb(205, 133, 63)Pink#FFC0CBrgb(255, 192, 203)Plum#DDA0DDrgb(221, 160, 221)PowderBlue#B0E0E6rgb(176, 224, 230)Purple#800080rgb(128, 0, 128)Red#FF0000rgb(255, 0, 0)RosyBrown#BC8F8Frgb(188, 143, 143)RoyalBlue#4169E1rgb(65, 105, 225)SaddleBrown#8B4513rgb(139, 69, 19)Salmon#FA8072rgb(250, 128, 114)SandyBrown#F4A460rgb(244, 164, 96)SeaGreen#2E8B57rgb(46, 139, 87)SeaShell#FFF5EErgb(255, 245, 238)Sienna#A0522Drgb(160, 82, 45)Silver#C0C0C0rgb(192, 192, 192)SkyBlue#87CEEBrgb(135, 206, 235)SlateBlue#6A5ACDrgb(106, 90, 205)SlateGray#708090rgb(112, 128, 144)Snow#FFFAFArgb(255, 250, 250)SpringGreen#00FF7Frgb(0, 255, 127)SteelBlue#4682B4rgb(70, 130, 180)Tan#D2B48Crgb(210, 180, 140)Teal#008080rgb(0, 128, 128)Thistle#D8BFD8rgb(216, 191, 216)Tomato#FF6347rgb(255, 99, 71)Turquoise#40E0D0rgb(64, 224, 208)Violet#EE82EErgb(238, 130, 238)VioletRed#D02090rgb(208, 32, 144)Wheat#F5DEB3rgb(245, 222, 179)White#FFFFFFrgb(255, 255, 255)WhiteSmoke#F5F5F5rgb(245, 245, 245)Yellow#FFFF00rgb(255, 255, 0)YellowGreen#9ACD32rgb(154, 205, 50)]]></content>
      <categories>
        <category>Color</category>
      </categories>
      <tags>
        <tag>颜色</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习]]></title>
    <url>%2F2018%2F09%2F21%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[通用名词ML 名词解释： 机器学习(Machine Learning)是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。 它是人工智能的核心，是使计算机具有智能的根本途径，其应用遍及人工智能的各个领域，它主要使用归纳、综合而不是演绎。 DL 名词解释： 深度学习（Deep Learning）是机器学习拉出的分支，它试图使用包含复杂结构或由多重非线性变换构成的多个处理层对数据进行高层抽象的算法。 深度学习是机器学习中表征学习方法。观测值（例如一幅图像）可以使用多种方式来表示，如每个像素强度值的矢量，或者更抽象地表示成一系列边、特定形状的区域等。而使用某些特定的表示方法更容易从实例中学习任务（例如，人脸识别或面部表情识别）。深度学习的好处是将用非监督式或半监督式的特征学习和分层特征提取的高效算法来替代手工获取特征。 CNN 名词解释： 卷积神经网络（Convolutional neural networks，简称CNNs）是一种深度的监督学习下的机器学习模型 算法名词KNN: 名词解释： 邻近算法，或者说K最近邻(kNN，k-NearestNeighbor)分类算法。 邻近算法是数据挖掘分类技术中最简单的方法之一。所谓K最近邻，就是k个最近的邻居的意思，说的是每个样本都可以用它最接近的k个邻居来代表。 kNN算法的核心思想是如果一个样本在特征空间中的k个最相邻的样本中的大多数属于某一个类别，则该样本也属于这个类别，并具有这个类别上样本的特性。该方法在确定分类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。 kNN方法在类别决策时，只与极少量的相邻样本有关。由于kNN方法主要靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别的，因此对于类域的交叉或重叠较多的待分样本集来说，kNN方法较其他方法更为适合。 SVM: 名词解释： 支持向量机（Support Vector Machine）。 在机器学习领域，支持向量机SVM(Support Vector Machine)是一个有监督的学习模型，通常用来进行模式识别、分类、以及回归分析。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux(二)]]></title>
    <url>%2F2018%2F09%2F21%2FLinux2%2F</url>
    <content type="text"><![CDATA[Ubuntu 图形界面入门目标 熟悉 Ubuntu 图形界面的基本使用 01. Ubuntu 的任务栏 02. 窗口操作按钮 03. 窗口菜单条]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux(一)]]></title>
    <url>%2F2018%2F09%2F20%2FLinux1%2F</url>
    <content type="text"><![CDATA[Linux 终端命令格式目标 了解终端命令格式 知道如何查阅终端命令帮助信息 01. 终端命令格式1command [-options] [parameter] 说明： command：命令名，相应功能的英文单词或单词的缩写 [-options]：选项，可用来对命令进行控制，也可以省略 parameter：传给命令的参数，可以是 零个、一个 或者 多个 [] 代表可选 02. 查阅命令帮助信息（知道） 提示 现阶段只需要 知道 通过以下两种方式可以查询命令的帮助信息 先学习常用命令及常用选项的使用即可，工作中如果遇到问题可以借助 网络搜索 2.1 --help1command --help 说明： 显示 command 命令的帮助信息 2.2 man1man command 说明： 查阅 command 命令的使用手册 man 是 manual 的缩写，是 Linux 提供的一个 手册，包含了绝大部分的命令、函数的详细使用说明 使用 man 时的操作键： 操作键 功能 空格键 显示手册页的下一屏 Enter 键 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 退出 /word 搜索 word 字符串]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSDN MarkDown模板]]></title>
    <url>%2F2018%2F09%2F12%2FCSDN-MarkDown%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[欢迎使用Markdown编辑器写博客本Markdown编辑器使用StackEdit修改而来，用它写博客，将会带来全新的体验哦： Markdown和扩展Markdown简洁的语法 代码块高亮 图片链接和图片上传 LaTex数学公式 UML序列图和流程图 离线写博客 导入导出Markdown文件 丰富的快捷键 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z 重做 Ctrl + Y Markdown及扩展 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接等，详细语法参考帮助？。 本编辑器支持 Markdown Extra , 扩展了很多好用的功能。具体请参考Github. 表格Markdown Extra 表格语法： 项目 价格 Computer $1600 Phone $12 Pipe $1 可以使用冒号来定义对齐方式： 项目 价格 数量 Computer 1600 元 5 Phone 12 元 12 Pipe 1 元 234 ###定义列表 Markdown Extra 定义列表语法：项目１项目２: 定义 A: 定义 B 项目３: 定义 C : 定义 D 定义D内容 代码块代码块语法遵循标准markdown代码，例如：12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' ###脚注生成一个脚注[^footnote]. [^footnote]: 这里是 脚注 的 内容，会显示在页面的最后。 目录用 [TOC]来生成目录： [TOC] 数学公式使用MathJax渲染LaTex 数学公式，详见math.stackexchange.com. 行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。 块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ 更多LaTex语法请参考 这儿. UML 图:可以渲染序列图： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 或者流程图： 123456789st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 关于 序列图 语法，参考 这儿, 关于 流程图 语法，参考 这儿. 离线写博客即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入write.blog.csdn.net/mdeditor即可。Markdown编辑器使用浏览器离线存储将内容保存在本地。 用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。 博客发表后，本地缓存将被删除。 用户可以选择 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。 注意：虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，请务必及时发表或者保存到服务器草稿箱。 ##浏览器兼容 目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。 IE９以下不支持 IE９，１０，１１存在以下问题 不支持离线功能 IE9不支持文件导入导出 IE10不支持拖拽文件导入]]></content>
      <categories>
        <category>Markdown模板</category>
      </categories>
      <tags>
        <tag>CSDN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教师资格证]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%95%99%E5%B8%88%E8%B5%84%E6%A0%BC%E8%AF%81%E5%BF%85%E8%BF%87%2F</url>
    <content type="text"><![CDATA[不要担心距离教资考试还有几天，找我拿资料就对了！！1、资源来之不易，重要程度可想而知2、基础知识掌握后，请认真作答该套密卷3、中小学都有4、拿到资料后，大家不要再迷失方向，胡乱找资料，看网课，这些都没用，只会耽误时间！！！抓紧时机看我的资料 保证没问题！！！5、最后，我祝愿大家能够考出一个好成绩！6、如有问题可以问我，我为大家排忧解难！！！我与大家同在！！！（企鹅及时联系）8、qq:409011616]]></content>
      <categories>
        <category>考试</category>
      </categories>
      <tags>
        <tag>教师资格证考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平凡的一天]]></title>
    <url>%2F2018%2F09%2F12%2FPFDYT%2F</url>
    <content type="text"><![CDATA[平凡的一天 毛不易 每个早晨七点半就自然醒风铃响起又是一天云很轻晒好的衣服味道很安心一切都是柔软又宁静每个路口花都开在阳光里小店门前传来好听的恋曲不用太久就能走到目的地人来人往里满是善意这是最平凡的一天啊你也想念吗不追不赶慢慢走回家就这样虚度着年华 没牵挂只有晚风轻拂着脸颊日落之前斜阳融在小河里逛了黄昏市场收获很满意朋友打来电话说他在等你见面有聊不完的话题餐桌摆在开满花的院子里微微酒意阵阵欢歌笑语从不考虑明天应该去哪里因为今夜的风太和煦这是最平凡的一天啊你也想念吗不追不赶慢慢走回家就这样虚度着年华 没牵挂只有晚风轻拂着脸颊这是最完美的一天啊你也想要吗生活可以不那么复杂就这样虚度着年华 没牵挂只有晚风轻拂着脸颊总有一天 我们会找到她]]></content>
      <categories>
        <category>music</category>
      </categories>
      <tags>
        <tag>毛不易</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSDNMarkDown]]></title>
    <url>%2F2018%2F09%2F08%2FCSDNMarkDownup%2F</url>
    <content type="text"><![CDATA[欢迎使用Markdown编辑器写博客本Markdown编辑器使用StackEdit修改而来，用它写博客，将会带来全新的体验哦： Markdown和扩展Markdown简洁的语法 代码块高亮 图片链接和图片上传 LaTex数学公式 UML序列图和流程图 离线写博客 导入导出Markdown文件 丰富的快捷键 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z 重做 Ctrl + Y Markdown及扩展 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。— 维基百科 使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接等，详细语法参考帮助？。 本编辑器支持 Markdown Extra , 扩展了很多好用的功能。具体请参考Github. 表格Markdown Extra 表格语法： 项目 价格 Computer $1600 Phone $12 Pipe $1 可以使用冒号来定义对齐方式： 项目 价格 数量 Computer 1600 元 5 Phone 12 元 12 Pipe 1 元 234 ###定义列表 Markdown Extra 定义列表语法：项目１项目２: 定义 A: 定义 B 项目３: 定义 C : 定义 D &gt; 定义D内容 代码块代码块语法遵循标准markdown代码，例如：12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' ###脚注生成一个脚注[^footnote]. [^footnote]: 这里是 脚注 的 内容. 目录用 [TOC]来生成目录： [TOC] 数学公式使用MathJax渲染LaTex 数学公式，详见math.stackexchange.com. 行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。 块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ 更多LaTex语法请参考 这儿. UML 图:可以渲染序列图： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 或者流程图： 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 关于 序列图 语法，参考 这儿, 关于 流程图 语法，参考 这儿. 离线写博客即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入write.blog.csdn.net/mdeditor即可。Markdown编辑器使用浏览器离线存储将内容保存在本地。 用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。 博客发表后，本地缓存将被删除。 用户可以选择 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。 注意：虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，请务必及时发表或者保存到服务器草稿箱。 ##浏览器兼容 目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。 IE９以下不支持 IE９，１０，１１存在以下问题 不支持离线功能 IE9不支持文件导入导出 IE10不支持拖拽文件导入]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown_use]]></title>
    <url>%2F2018%2F09%2F07%2FMarkdown-use%2F</url>
    <content type="text"><![CDATA[Markdown及扩展 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接等，详细语法参考帮助？。 表格Markdown Extra 表格语法： 项目 价格 Computer $1600 Phone $12 Pipe $1 可以使用冒号来定义对齐方式： 项目 价格 数量 Computer 1600 元 5 Phone 12 元 12 Pipe 1 元 234 ###定义列表 Markdown Extra 定义列表语法：项目１项目２: 定义 A: 定义 B 项目３: 定义 C : 定义 D &gt; 定义D内容 代码块代码块语法遵循标准markdown代码，例如：hahhahha123sdkskdjksjdsdasdnsmdnadsksa 12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' ###脚注生成一个脚注[^footnote]. [^footnote]: 这里是 脚注 的 内容. 目录用 [TOC]来生成目录： [TOC] 数学公式使用MathJax渲染LaTex 数学公式，详见math.stackexchange.com. 行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。 块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ 更多LaTex语法请参考 这儿. UML 图:可以渲染序列图： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 或者流程图： 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 关于 序列图 语法，参考 这儿, 关于 流程图 语法，参考 这儿. 离线写博客即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入write.blog.csdn.net/mdeditor即可。Markdown编辑器使用浏览器离线存储将内容保存在本地。 用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。 博客发表后，本地缓存将被删除。 用户可以选择 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。 注意：虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，请务必及时发表或者保存到服务器草稿箱。 ##浏览器兼容 目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。 IE９以下不支持 IE９，１０，１１存在以下问题 不支持离线功能 IE9不支持文件导入导出 IE10不支持拖拽文件导入]]></content>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令总结]]></title>
    <url>%2F2017%2F12%2F08%2Fhexo-github-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[HEXO命令总结&emsp;&emsp;hexo是一个个人网站生成器，它基于node.js，可快速、简单、强大的生成静态博客框架。hexo官网：Hexo官网 1.hexo123npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 2.简写12345hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 3.服务器12345678hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 123$ hexo clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 123list$ hexo list &lt;type&gt;列出网站资料。 123version$ hexo version显示 Hexo 版本。 4.监视文件变动12hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 5.部署123456两个命令的作用是相同的hexo generate --deployhexo deploy --generatehexo deploy -ghexo server -g 6.草稿1hexo publish [layout] &lt;title&gt; ##发表草稿。 7.1模板123456789hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHubhexo new [layout] &lt;title&gt;hexo new photo &quot;My Gallery&quot;hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 12345678title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: To be number one! 7.2模版（Scaffold）1hexo new photo &quot;My Gallery&quot; 变量 描述 layout 布局 title 标题 date 文件建立日期 8.设置文章摘要1以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 9.报错处理(1)找不到git部署 ERROR Deployer not found: git 12#解决办法npm install hexo-deployer-git --save 10.参数说明 (1)config.yml &emsp;&emsp;网站的 配置 信息，您可以在此配置大部分的参数。 &emsp;&emsp; (2)package.json:应用程序的信息。 1234567891011121314151617181920package.json&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.0.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.0&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.0&quot;, &quot;hexo-generator-index&quot;: &quot;^0.1.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.1.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.1.0&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.2.4&quot;, &quot;hexo-server&quot;: &quot;^0.1.2&quot; &#125;&#125; (3)scaffolds&emsp;&emsp;模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 (4)source&emsp;&emsp;资源文件夹是存放用户资源的地方。 &emsp;&emsp; (5)themes&emsp;&emsp;主题文件夹。Hexo 会根据主题来生成静态页面。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jekyll搭建个人博客(二)]]></title>
    <url>%2F2017%2F09%2F05%2Fjekyll_tutorials2%2F</url>
    <content type="text"><![CDATA[抱歉，太久没有更新博客了，很多网友问的问题也没能及时回答。具体原因就不说了，今后我会继续维护博客，有问题的朋友直接提问就行，我会尽快解答，希望大家多多支持。 在此之前我有写过一篇如何使用我博客模板的文章 请先看这篇基础集成，这篇文章主要讲的是如何使用和修改我的博客主题，文章内容含以下几点： 修改博客基础信息 发布文章 修改博客样式 博客模板根目录下的基本结构为 1234567891011121314151617181920.├── _config.yml ├── _includes ├── _layouts├── _posts├── _site├── 404.html├── about.md├── archive.html├── CNAME├── css├── feed.xml├── Gemfile├── Gemfile.lock├── images├── index.html├── js├── Rakefile├── README.md└── tags.html]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发中的小问题记录]]></title>
    <url>%2F2016%2F12%2F02%2F2016-12-02-iOS_Dev_Note%2F</url>
    <content type="text"><![CDATA[NSKeyedArchiver 自定义对象写文件如果存储的对象类名有变动，则需要设置clasName, 方法为：“setClassName:forClass:”使用 NSKeyedArchiver 进行数据持久化时, 系统会默认使用类名去建表，如果类名变了，那么使用新的类名肯定是从本地获取不到表的，代码执行崩溃。所以需要在 NSKeyedArchiver 或者 NSKeyedUnarchiver 时使用 “setClassName:forClass:” 指定类名。 断点配置：【Generate Debug Symbols】描述: 用来控制断点是否生效,关闭此功能，打包 .ipa 时，包体积会小很多。配置路径:【project/TARGETS/Build Settings/Apple LLVM7.1 - Code Genneration/Generate Debug Symbols】 捕获全局异常：【All Exception】描述: 用来捕捉整个项目在 Xcode 里执行时的异常。例如：try/catch 时 catch住的异常,【All Exception】可以直接定位到具体位置。配置路径: 异常捕捉(commod+7)/Xcode左下角点击+/Add Exception Breakpoint/完成(回车键) UI相关1、设置状态栏颜色： 123info.plist 添加 View controller-based status bar appearance - NO 代码里写 [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent]; 再次运行后状态栏就会变成白色。 2、左滑返回手势失效了怎么办： 1234设置 navigationItem.leftBarButtonItem 之后，左滑返回手势就会失效。设置一下 UIGestureRecognizerDelegate 代理即可：self.navigationController.interactivePopGestureRecognizer.delegate = self; 3、让 TableView的 下拉 和 上拉 显示不一样的背景颜色： 1234给 TableView 上加一个 View，View 的 Frema：CGRectMake(0, -self.view.bounds.size.height, self.view.bounds.size.width, self.view.bounds.size.height + 2)，给变View的背景颜色就可以了。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 TensorFlow 实现神经网络]]></title>
    <url>%2F2016%2F11%2F20%2F2016-11-20-neural_networks_using_TensorFlow%2F</url>
    <content type="text"><![CDATA[介绍 一直关注 数据科学 、 机器学习 的同学，一定会经常看到或听到关于 深度学习 和 神经网络 相关信息。如果你对 深度学习 感兴趣，但却还没有实际动手操作过，你可以从这里得到实践。 在本文中，我将介绍 TensorFlow , 帮你了解 神经网络 的实际作用，并使用 TensorFlow 来解决现实生活中的问题。 读这篇文章前，需要知道 神经网络 的基础知识和一些熟悉编程理念，文章中的代码是使用 Pyhton 编写的，所以还需要了解一些 Python 的基本语法，才能更有利对于文章的理解。 目录 什么时候应用神经网络？ 通常神经网络能解决的问题 了解图像数据和主流的库来解决问题 什么是 TensorFlow？ TensorFlow 一个 典型 的 “ 流 ” 在 TensorFlow 中实现 MLP TensorFlow 的限制 TensorFlow 与其他库 从这里去哪里？ 什么时候用神经网络？ 神经网络 已经在相当一段时间成为机器学习中的焦点。 对于 神经网络 和 深度学习 上这里有更详细的解释 点击阅读 。 其 “更深” 的功能在许多领域都有取得巨大的突破，如图像识别，语音和自然语言处理等。 主要的问题在于如何用好 神经网络 ？现在，每天都会有许多新发现，这个领域就像一个金矿，为了成为这个 “淘金热” 的一部分，必须记住几件事： 首先，神经网络 需要有明确和翔实的数据（主要是大数据）训练， 试着想象 神经网络 作为一个孩子，它一开始会观察它父母走路，然后它试图自己走，每一步就像学习执行一个特定的任务。 它可能会失败几次，但经过几次失败的尝试，它将会如何走路。所以需要为孩子提供更多的机会，如果不让它走，它可能永远不会学习如何走路。 一些人会利用 神经网络 解决复杂的问题，如图像处理， 神经网络 属于一类代表学习的算法，这些算法可以把复杂的问题分解为简单的形式，使他们成为可以理解的（或 “可表示”），就像吞咽食物之前的咀嚼，让我们更容易吸收和消化。这个分解的过程如果使用传统的算法来实现也可以，但是实现过程将会很困难。 选择适当类型的 神经网络 ，来解决问题， 每个问题的复杂情况都不一样，所以数据决定你解决问题的方式。 例如，如果问题是序列生成的问题，递归神经网络 更合适。如果它是图像相关的问题，想更好地解决可以采取 卷积神经网络。 最后最重要的就是 硬件 要求了，硬件是运行 神经网络 模型的关键。 神经网被 “发现” 很久以前，他们在近年来得到推崇的主要的原因就是计算资源更好，能更大发挥它的光芒，如果你想使用 神经网络 解决这些现实生活中的问题，那么你得准备购买一些高端的硬件了😆！ 通常神经网络解决的问题 神经网络是一种特殊类型的 机器学习（ML）算法。 因此，作为每个 ML 算法都遵循 数据预处理 、模型建立 和 模型评估 的工作流流程。为了简明起见，下面列出了如何处理 神经网络 问题的 TODO 列表。 检查它是否为 神经网络 ，把它看成一个传统的算法问题 做一个调查，哪个 神经网络 框架最适合解决这个问题 定义 神经网络 框架，通过它选择对应的 编程语言 和 库 将数据转换为正确的格式并分批分割 根据您的需要预处理数据 增强数据以增加大小并制作更好的训练模型 批次供给到 神经网络 训练和监测，培训和验证数据集的变化 测试你的模型，并保存以备将来使用 本文将专注于图像数据，我们从 TensorFlow 入手。 了解图像数据和主流的库来解决问题 图像大多排列为 3-D 阵列，具体指 高度、宽度 和 颜色通道。例如，如果你使用电脑截屏，它将首先转换成一个 3-D 数组，然后压缩它为 ‘.jpeg’ 或 ‘.png’ 文件格式。 虽然这些图像对于人类来说很容易理解，但计算机很难理解它们。 这种现象称为“语义空隙”。我们的大脑可以看看图像，并在几秒钟内读懂完整的图片。但计算机会将图像看作一个数字数组，问题来了，它想知道这是一张什么样的图像，我们应该怎么样把图像解释给机器它才能读懂？ 在早期，人们试图将图像分解为机器的 “可理解” 格式，如“模板”。例如，面部总是具有在每个人中有所保留的特定结构，例如眼睛，鼻子或我们的脸的形状。 但是这种方法将是有缺陷的，因为当要识别的对象的数量将增加到一定量级时，“模板” 将不成立。 2012年一个深层神经网络架构赢得了 ImageNet 的挑战，从自然场景中识别对象，它在即将到来的 ImageNet 挑战中继续统治其主权，从而证明了解决图像问题的有用性。人们通常使用哪些 库 / 语言 来解决图像识别问题？最近的一次调查中，最流行的深度学习库，支持的最友好的语言有 Python ，其次是 Lua ，对 Java 和 Matlab 支持的也有。最流行的库举几个例子： Caffe DeepLearning4j TensorFlow Theano Torch 现在，我们了解了图像的存储方式以及使用的常用库，让我们看看 TensorFlow 提供的功能。 什么是 TensorFlow ？让我们从官方定义开始. “TensorFlow 是一个开源软件库，用于使用数据流图进行数值计算。图中的节点表示数学运算，而图边表示在它们之间传递的多维数据阵列（也称为张量）。 灵活的架构允许您使用单一 API 将计算部署到桌面、服务器或移动设备中的一个或多个的 CPU 或 GPU 中。 如果感觉这听起来太高大上，不要担心。这里有我简单的定义，TensorFlow 看起来没什么，只是 numpy 有些难以理解。如果你以前使用过 numpy ，理解 TensorFlow 将是手到擒来！ numpy 和 TensorFlow 之间的主要区别是 TensorFlow 遵循惰性编程范例。 TensorFlow 的操作基本上都是对 session 的操作，它首先构建一个所有操作的图形，当我们调用 session 时 TensorFlow 就开始工作了。它通过将内部数据表示转换为张量（Tensor，也称为多维数组）来构建为可扩展的。 构建计算图可以被认为是 TensorFlow 的主要成分。想更多地了解一个计算图形的数学结构，可以阅读 这篇文章 。 通过上面的介绍，很容易将 TensorFlow 分类为神经网络库，但它不仅仅是如此。它被设计成一个强大的神经网络库， 但它有能力做更多的事情。可以构建它为其他机器学习算法，如 决策树 或 k-最近邻，你可以从字面上理解，你可以做一切你在 numpy 上能做的事情！我们暂且称它为 “全能的 numpy” 。 使用 TensorFlow 的优点是： 它有一个直观的结构 ，顾名思义它有 “张量流”，你可以轻松地可视每个图中的每一个部分。 轻松地在 cpu / gpu 上进行分布式计算 平台的灵活性 。可以随时随地运行模型，无论是在移动端、服务器还是 PC 上。 TensorFlow 的典型 “流” 每个库都有自己的“实现细节”，即一种写其遵循其编码范例的方式。 例如，当实现 scikit-learn 时，首先创建所需算法的对象，然后在训练和测试集上构建一个模型获得预测，如下所示： 1234567# define hyperparamters of ML algorithmclf = svm.SVC(gamma=0.001, C=100.)# train clf.fit(X, y)# test clf.predict(X_test) 正如我前面所说，TensorFlow 遵循一种懒惰的方法。 在 TensorFlow 中运行程序的通常工作流程如下： 建立一个计算图， 任何的数学运算可以使用 TensorFlow 支撑。 初始化变量， 编译预先定义的变量 创建 session， 这是神奇的开始的地方 ！ 在 session 中运行图， 编译图形被传递到 session ，它开始执行它。 关闭 session， 结束这次使用。 TensoFlow 中使用的术语很少 12placeholder：将数据输入图形的一种方法feed_dict：将数值传递到计算图的字典 让我们写一个小程序来添加两个数字！ 1234567891011121314151617181920# import tensorflowimport tensorflow as tf# build computational grapha = tf.placeholder(tf.int16)b = tf.placeholder(tf.int16)addition = tf.add(a, b)# initialize variablesinit = tf.initialize_all_variables()# create session and run the graphwith tf.Session() as sess: sess.run(init) print &quot;Addition: %i&quot; % sess.run(addition, feed_dict=&#123;a: 2, b: 3&#125;)# close sessionsess.close() 在 TensorFlow 中实现神经网络注意：我们可以使用不同的神经网络体系结构来解决这个问题，但是为了简单起见，我们在深入实施中讨论 前馈多层感知器。 让我们记住对神经网络的了解。 神经网络的典型实现如下： 定义要编译的神经网络体系结构 将数据传输到模型 整个运行中，数据首先被分成批次，以便它可以被摄取。首先对批次进行预处理，扩增，然后送入神经网络进行训练 然后，模型被逐步地训练 显示特定数量的时间步长的精度 训练后保存模型供将来使用 在新数据上测试模型并检查其运行方式 在这里，我们解决了我们深刻的学习实践中的问题 - [识别数字]，让再我们花一点时间看看问题陈述。 我们的问题是图像识别，以识别来自给定的 28×28 图像的数字。 我们有一个图像子集用于训练，其余的用于测试我们的模型。首先下载训练和测试文件。数据集包含数据集中所有图像的压缩文件， train.csv 和 test.csv 都有相应的训练和测试图像的名称。数据集中不提供任何其他功能，只是原始图像以 “.png” 格式提供。 如之前说的，我们将使用 TensorFlow 来创建一个神经网络模型。 所以首先在你的系统中安装 TensorFlow 。 请参考 官方的安装指南 进行安装，按您的系统规格。 我们将按照上述模板 让我们来 导入所有需要的模块 123456789%pylab inlineimport osimport numpy as npimport pandas as pdfrom scipy.misc import imreadfrom sklearn.metrics import accuracy_scoreimport tensorflow as tf 让我们来 设置一个种子值，这样我们就可以控制我们的模型随机性 1234# To stop potential randomnessseed = 128rng = np.random.RandomState(seed) 第一步是设置目录路径，以便保管！ 123456789root_dir = os.path.abspath('../..')data_dir = os.path.join(root_dir, 'data')sub_dir = os.path.join(root_dir, 'sub')# check for existenceos.path.exists(root_dir)os.path.exists(data_dir)os.path.exists(sub_dir) 现在让我们读取我们的数据集，这些是 .csv 格式，并有一个文件名以及相应的标签 12345train = pd.read_csv(os.path.join(data_dir，'Train'，'train.csv'))test = pd.read_csv(os.path.join（data_dir，'Test.csv'))sample_submission = pd.read_csv(os.path.join(data_dir，'Sample_Submission.csv'))train.head() 文件名 标签 0 0.png 4 1 1.png 9 2 2.png 1 3 3.png 7 4 4.png 3 让我们看看我们的数据是什么样子！我们读取我们的形象并显示出来。 123456789img_name = rng.choice(train.filename)filepath = os.path.join(data_dir, 'Train', 'Images', 'train', img_name)img = imread(filepath, flatten=True)pylab.imshow(img, cmap='gray')pylab.axis('off')pylab.show() 上面的图像表示为 numpy 数组，如下所示 为了方便数据操作，让我们 的存储作为 numpy 的阵列的所有图片 123456789101112131415161718temp = []for img_name in train.filename: image_path = os.path.join(data_dir, 'Train', 'Images', 'train', img_name) img = imread(image_path, flatten=True) img = img.astype('float32') temp.append(img) train_x = np.stack(temp)temp = []for img_name in test.filename: image_path = os.path.join(data_dir, 'Train', 'Images', 'test', img_name) img = imread(image_path, flatten=True) img = img.astype('float32') temp.append(img) test_x = np.stack(temp) 由于这是典型的 ML 问题，为了测试我们的模型的正确功能，我们创建一个验证集，让我们以 70:30 的分割训练集 和 验证集 12345split_size = int(train_x.shape[0]*0.7)train_x, val_x = train_x[:split_size], train_x[split_size:]train_y, val_y = train.label.values[:split_size], train.label.values[split_size:] 我们定义一些辅助函数，我们稍后在我们的程序中使用 12345678910111213141516171819202122232425262728def dense_to_one_hot(labels_dense, num_classes=10): """Convert class labels from scalars to one-hot vectors""" num_labels = labels_dense.shape[0] index_offset = np.arange(num_labels) * num_classes labels_one_hot = np.zeros((num_labels, num_classes)) labels_one_hot.flat[index_offset + labels_dense.ravel()] = 1 return labels_one_hotdef preproc(unclean_batch_x): """Convert values to range 0-1""" temp_batch = unclean_batch_x / unclean_batch_x.max() return temp_batchdef batch_creator(batch_size, dataset_length, dataset_name): """Create batch with random samples and return appropriate format""" batch_mask = rng.choice(dataset_length, batch_size) batch_x = eval(dataset_name + '_x')[[batch_mask]].reshape(-1, 784) batch_x = preproc(batch_x) if dataset_name == 'train': batch_y = eval(dataset_name).ix[batch_mask, 'label'].values batch_y = dense_to_one_hot(batch_y) return batch_x, batch_y 主要部分！ 让我们定义我们的神经网络架构。 我们定义一个神经网络具有 3 层，输入、隐藏 和 输出， 输入和输出中的神经元数目是固定的，因为输入是我们的 28×28 图像，并且输出是表示类的 10×1 向量。 我们在隐藏层中取 500 神经元。这个数字可以根据你的需要变化。我们把值 赋给 其余变量。 可以阅读 [神经网络的基础知识的文章] ，以更深的了解它是如何工作。 12345678910111213141516171819202122232425262728293031### set all variables# number of neurons in each layerinput_num_units = 28*28hidden_num_units = 500output_num_units = 10# define placeholdersx = tf.placeholder(tf.float32, [None, input_num_units])y = tf.placeholder(tf.float32, [None, output_num_units])# set remaining variablesepochs = 5batch_size = 128learning_rate = 0.01### define weights and biases of the neural network (refer this article if you don't understand the terminologies)weights = &#123; 'hidden': tf.Variable(tf.random_normal([input_num_units, hidden_num_units], seed=seed)), 'output': tf.Variable(tf.random_normal([hidden_num_units, output_num_units], seed=seed))&#125;biases = &#123; 'hidden': tf.Variable(tf.random_normal([hidden_num_units], seed=seed)), 'output': tf.Variable(tf.random_normal([output_num_units], seed=seed))&#125; 现在创建我们的神经网络计算图 12345hidden_layer = tf.add(tf.matmul(x, weights['hidden']), biases['hidden'])hidden_layer = tf.nn.relu(hidden_layer)output_layer = tf.matmul(hidden_layer, weights['output']) + biases['output'] 此外，我们需要定义神经网络的成本 12cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(output_layer, y)) 设置优化器，即我们的反向传播算法。 这里我们使用 Adam ，这是梯度下降算法的高效变体。 有在 tensorflow 可用许多其它优化（参照 此处 ） 12optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate).minimize(cost) 定义我们的神经网络结构后，让我们来 初始化所有的变量 12init = tf.initialize_all_variables() 现在让我们创建一个 Session ，并在 Session 中运行我们的神经网络。我们还验证我们创建的验证集的模型准确性 1234567891011121314151617181920212223242526272829303132with tf.Session() as sess: # create initialized variables sess.run(init) ### for each epoch, do: ### for each batch, do: ### create pre-processed batch ### run optimizer by feeding batch ### find cost and reiterate to minimize for epoch in range(epochs): avg_cost = 0 total_batch = int(train.shape[0]/batch_size) for i in range(total_batch): batch_x, batch_y = batch_creator(batch_size, train_x.shape[0], 'train') _, c = sess.run([optimizer, cost], feed_dict = &#123;x: batch_x, y: batch_y&#125;) avg_cost += c / total_batch print "Epoch:", (epoch+1), "cost =", "&#123;:.5f&#125;".format(avg_cost) print "\nTraining complete!" # find predictions on val set pred_temp = tf.equal(tf.argmax(output_layer, 1), tf.argmax(y, 1)) accuracy = tf.reduce_mean(tf.cast(pred_temp, "float")) print "Validation Accuracy:", accuracy.eval(&#123;x: val_x.reshape(-1, 784), y: dense_to_one_hot(val_y.values)&#125;) predict = tf.argmax(output_layer, 1) pred = predict.eval(&#123;x: test_x.reshape(-1, 784)&#125;) 这将是上面代码的输出 123456789Epoch: 1 cost = 8.93566Epoch: 2 cost = 1.82103Epoch: 3 cost = 0.98648Epoch: 4 cost = 0.57141Epoch: 5 cost = 0.44550Training complete!Validation Accuracy: 0.952823 验证我们自己的眼睛，让我们来 想象它的预言 12345678910111213img_name = rng.choice(test.filename)filepath = os.path.join(data_dir, 'Train', 'Images', 'test', img_name)img = imread(filepath, flatten=True) test_index = int(img_name.split('.')[0]) - 49000print "Prediction is: ", pred[test_index]pylab.imshow(img, cmap='gray')pylab.axis('off')pylab.show() 12Prediction is: 8 我们看到的模型性能是相当不错！ 现在让我们 创建一个提交 123456sample_submission.filename = test.filename sample_submission.label = predsample_submission.to_csv(os.path.join(sub_dir, 'sub01.csv'), index=False) 终于完成了！ 我们刚刚创建了自己的训练神经网络！ TensorFlow 的限制 尽管 TensorFlow 是强大的，它仍然是一个低水平库，例如，它可以被认为是机器级语言，但对于大多数功能，您需要自己去模块化和高级接口，如 keras 它仍然在继续开发和维护，这是多么👍啊！ 它取决于你的硬件规格，配置越高越好 不是所有变成语言能使用它的 API 。 TensorFlow 中仍然有很多库需要手动导入，比如 OpenCL 支持。 上面提到的大多数是在 TensorFlow 开发人员的愿景，他们已经制定了一个路线图，计划库未来应该如何开发。 TensorFlow 与其他库 TensorFlow 建立在类似的原理，如使用数学计算图表的 Theano 和 Torch，但是随着分布式计算的额外支持，TensorFlow 更好地解决复杂的问题。 此外，TensorFlow 模型的部署已经被支持，这使得它更容易用于工业目的，打开一些商业的三方库，如 Deeplearning4j ，H2O 和 Turi。 TensorFlow 有用于 Python，C ++ 和 Matlab 的 API 。 最近还出现了对 Ruby 和 R 等其他语言的支持。因此，TensorFlow 试图获得通用语言支持。 从这里去哪里？ 以上你看到了如何用 TensorFlow 构建一个简单的神经网络，这段代码是为了让人们了解如何开始实现 TensorFlow。 要解决更复杂的现实生活中的问题，你必须在这篇文章的基础上在调整一些代码才行。 许多上述功能可以被抽象为给出无缝的端到端工作流，如果你使用 scikit-learn ，你可能知道一个高级库如何抽象“底层”实现，给终端用户一个更容易的界面。尽管 TensorFlow 已经提取了大多数实现，但是也有更高级的库，如 TF-slim 和 TFlearn。 参考资源 TensorFlow 官方库 Rajat Monga（TensorFlow技术负责人） “TensorFlow为大家” 的视频 一个专用资源的策划列表 关于原文感谢原文作者 Faizan Shaikh 的分享，这篇文章是在 An Introduction to Implementing Neural Networks using TensorFlow 的基础上做的翻译和局部调整，如果发现翻译中有不对或者歧义的的地方欢迎在下面评论里提问，我会加以修正 。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac知识整合]]></title>
    <url>%2F2016%2F11%2F16%2F2016-11-16-macTips%2F</url>
    <content type="text"><![CDATA[.DS_Store 文件是什么？.DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件，如文件的图标位置或背景色，相当于 Windows 的 desktop.ini。 1，禁止.DS_store 生成：打开 “终端” ，复制黏贴下面的命令，回车执行，重启Mac即可生效。 1defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE 2，恢复.DS_store生成： 1defaults delete com.apple.desktopservices DSDontWriteNetworkStores 显示隐藏文件在终端执行命令，显示隐藏文件 1defaults write com.apple.finder AppleShowAllFiles -bool true 恢复隐藏 1defaults write com.apple.finder AppleShowAllFiles -bool false 执行命令后需要重新打开能看到效果。 切换 Pyhton 环境我本地之前 Python 环境是 2.7.10 ，然后学习 Tensorflow 的时候，安装了 Python 3.5.2 ，把系统默认 Pyton 环境也设置成了 3.5.2 版本，今天运行以前写的 python 脚本发现运行不了了，因为python 2.7 和 3.5 的 语法有挺多改动，现在我需要把系统的 python 环境回退到 2.7。 可以直接修改 ~/.bash_profile 文件。 1、修改 vim ~/.bash_profile 1修改方式有很多种，使用 vim ，或者 cd ~/ 然后 open . 打开文件夹，找到 .bash_profile 文件，双击打开。 2、在.bash_profile 文件里添加下面参数 1alias python=&quot;/System/Library/Frameworks/Python.framework/Versions/2.7/bin/python2.7&quot; 3、使用命令 source ~/.bash_profile 或者重启 终端 就 OK 了 。 现在你再在终端输入 python 就会发现，显示的信息为 2.7 了 1234Python 2.7.10 (default, Oct 23 2015, 19:19:21) [GCC 4.2.1 Compatible Apple LLVM 7.0.0 (clang-700.0.59.5)] on darwinType "help", "copyright", "credits" or "license" for more information. 生成SSHKey过程1234567891.查看是否已经有了ssh密钥：`cd ~/.ssh` ，如果没有密钥则不会有此文件夹，有则备份删除。 2.生存密钥：ssh-keygen -t rsa -C “test@gmail.com”。 按3个回车，密码为空。 Your identification has been saved in /home/tekkub/.ssh/id_rsa.Your public key has been saved in /home/tekkub/.ssh/id_rsa.pub.The key fingerprint is:……………… 最后得到了两个文件：id_rsa和id_rsa.pub 使用版本控制器 SVN (versions) 添加.a库Xcode 自带的 svn 和 Versions 以及一些其它工具都不能上传”.a”文件 下面是在 Mac 上如何把 .a 添加到 SVN 里面的 1、打开终端，输入cd，空格，然后将需要上传的 .a 文件所在的文件夹（不是.a文件） 拖拽到终端（此办法无需输入繁琐的路径，快捷方便） 回车 2、之后再输入如下命令：svn add libGoogleAnalytics.a ，回车 之后会出现：A (bin) libGoogleAnalytics.a 表示添加成功，打开 Versions 就可以看到，刚才添加的 .a 文件，此时就可以手动上传了。 另外，请注意路径的正确性。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow 在 iOS 平台上的使用(一)]]></title>
    <url>%2F2016%2F11%2F03%2F2016-11-03-TensorFlowOniOSUse1%2F</url>
    <content type="text"><![CDATA[距离上次使用 TensorFlow 在iOS平台上做的小 Demo，已经过了四个月了，今天忽然想再看看,发现 Demo 已经不见了，我只能从头在编一次，这次发现编译 iOS 库，简单多了。 tensorflow 下载地址，tensorflow 最近提交的时间：2016-11-03，commit：7b7c02de56e013482b5fe5ab05e576dc98fe5742 。 下载完成后打开文件，找到目录 tensorflow-master/tensorflow/contrib/ios_examples 你会发现目录下有三个项目和一个 README.md 。 1benchmark 、 camera 、 simple 、README.md 如果你发现项目无法运行，请看这里 对于任何项目我们首先打开的应该是 README.md ，里面一般情况都会有介绍如何使用这个项目，tensorflow 也不会例外。README 开头就说了，这个目录里有如何在 iOS 平台上使用 tensorflow 的例子，但是需要注意几点： 你的 Xcode 版本必须是 7.3 或更高版本，并且有安装 command-line 工具 。 项目(Examples) 里必须包含一个静态库：libtensorflow-core.a 。 下载 Inception v1，解压后将 label 和 graph 放在 simple 和 camera 的项目中。 camera 项目的使用 camera 项目在 tensorflow-master/tensorflow/contrib/ios_examples 目录下，如果你是直接打开 camera 项目，编译你会发现报错缺少 imagenet_comp_graph_label_strings.txt 和 tensorflow_inception_graph.pb 两个文件，这两个文件上面已经说到了下载 Inception v1 解压得到。现在还差 静态库：libtensorflow-core.a ，这个需要我们自己编译。 编译静态库：libtensorflow-core.a进入目录：tensorflow-master/tensorflow/contrib/makefile，你可以看到一大堆 .sh 结尾的文件，找到 build_all_ios.sh ，Mac 上可以直接在 termina（终端）上运行命令编译 1$ sh build_all_ios.sh 这个编译的过程是很漫长的，一般在一个小时左右。也有可能你在编译的过程中会遇到问题，这次我只遇到一个问题： 12345configure.ac:30: error: required file &apos;build-aux/ltmain.sh&apos; not foundconfigure.ac:24: installing &apos;build-aux/missing&apos;Makefile.am: installing &apos;build-aux/depcomp&apos;parallel-tests: installing &apos;build-aux/test-driver&apos;autoreconf: automake failed with exit status: 1 解决方法是：先卸载 libtool 在重新安装，brew uninstall libtool &amp;&amp; brew install libtool 一个小时后。。。 如果编译没出问题，你可以在目录 tensorflow-master/tensorflow/contrib/makefile／gen/lib 下找到一个静态库：libtensorflow-core.a ，把这个静态库拷贝到 camera 项目中，然后编译运行。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode 8 使用笔记]]></title>
    <url>%2F2016%2F10%2F25%2F2016-10-25-Xcode8%2F</url>
    <content type="text"><![CDATA[最近使用 Xcode8遇到了一些问题，想记下来，发现简书上有位同学写了一篇很详细的教程 原文链接，比较懒惰的我就在他的基础上加了些我自己的一些笔记。 Interface Builder随着 14 年的 iPhone6 和 6P 出来之后，iPhone 的屏幕尺寸也越来越多，屏幕适配是一个需要解决的问题，以后不一定苹果又出什么尺寸的 iPhone 呢。 在 iPhone6 和 6P 发布的同一年，苹果推出的 Xcode6 中在原有的 Auto layout的基础上，添加了Size Classes新特性，通过这个新特性可以使用一个XIB或者SB文件，适配不同的屏幕以及iPhone和iPad两种设备。 在 Xcode8 中，苹果推出了更加强大的可视化编辑工具预览功能，可以在不运行App的情况下，预览当前XIB或SB在不同屏幕尺寸下的显示。(这个功能我记得之前Xcode就有，只是隐藏的比较深，苹果现在给拿到外面了) 选择一个XIB文件进去，点击下面红框的位置，会出现从3.5寸-5.5寸一系列屏幕尺寸的选项。直接点击不同屏幕尺寸，以及横竖屏选项，切换不同的屏幕显示。在iPad上还可以选择是否分屏，功能非常强大。 在右边有一个 Vary for Traits 选项，点击这个选项就可以同时显示所有可选的屏幕样式，功能和上面图片都一样，只是显示上看起来比较多。 还有一点，新创建的 XIB 控件尺寸，不再是之前 600*600 的方块了，而是默认是6s的长方形 XIB 文件，看起来舒服多了。 Target中General 的变化在 Xcode8 之前，都需要自己设置证书和描述文件。如果设置出现错误的情况下，还可以通过点击 Fix issue 来修复这个错误。但这有个问题就在于，Fix issue 选项并不是那么好用，有的时候设置是正确的这里也提示需要 Fix issue。 可能苹果也意识到这个问题的存在，在Xcode8中可以通过Automatically manage signing选项，让苹果为我们管理证书和配置文件，设置也都是由苹果来完成的。在Xcode8中新建项目，这个选项默认是被勾选的。 从上面图中可以看到，苹果帮我们自动管理了证书和配置文件。而且在之前的项目中，如果想要设置安装后显示在手机上的App名字，还需要自己到Info.plist文件中，修改Display Name字段，而现在直接在General中就可以做修改，这个修改和Info.plist是同步的。 但是，如果我想自己管理证书和描述文件呢？只需要去掉Automatically manage signing选项。 如果自己到Build Settings中手动设置证书和描述文件，可以发现Provisioning Profile选项已经被标明为Deprecated，也就是苹果并不推荐手动设置。 Xcode 插件升级 Xcode8 之后会发现，在 Xcode8 中所有第三方插件都失效了，并且连之前菜单栏的插件选项也不存在了。在之前很多 iOS 开发者，都是通过 Alcatraz 来管理插件的，现在 Alcatraz 也是不可用的。但是X code8 自身也对编译器进行了升级，将一些比较好的插件功能加入到 Xcode 中，例如单行高亮显示等。 在 Xcode8 中支持了开发插件工程，并且为我们提供了一个插件模板，开发的插件可以上传到App Store 下载。苹果这么做有一个原因在于，之前 Xcode和插件是运行在同一个进程的，所以插件的崩溃也会导致Xcode崩溃。苹果现在将插件作为一个单独的应用程序，分开进程运行，不会对Xcode带来其他影响。 Runtime Issues在开发过程中，因为语法或明显的代码错误(例如Retain Cycle)，编译器可以发现并报黄色或红色警告。但是一些因为代码逻辑导致的错误，编译器并没有办法找到。例如下面的这句代码，因为代码逻辑的问题导致两个数组相互引用，都不能释放。 这时候可以通过 Xcode8 提供的 Runtime Issues 新特性，查找到运行过程中出现的问题，并通过 Graph 的方式将问题可视化的展现给开发者。 Debug Memory Graph在Xcode6中出现了Debug View Hierarchy新特性，可以通过其调试当前App的视图层级，查找UI相关的bug非常方便。在Xcode8中苹果为开发者提供了Debug Memory Graph特性，通过这个新特性，可以直接选择一个对象，查看与其相关的内存关系。 Debug Memory Graph 和 Runtime Issues 可以配合使用，通过 Debug Memory Graph 分析内存关系完成后，点击 Runtime Issues 可以看到已经发现的内存问题。 Swift 3Xcode8 带来了新版本的 Swift3，新版本的Swift变化较大，如果旧版的Swift项目在Xcode8上编译可能会失败。对此，苹果为开发者提供了Swift迁移工具，听说不太好用(我没用过这个工具)。 如果不想立刻就迁移到Swift3，可以在Builder Settings中进行设置，选择Use Legacy Swift Language Version设置为YES，就可以继续使用旧版本的Swift2.3。 其他更新Xcode 新版字体，SF Mono Regular 字体。更新 Xcode 之后我比较喜欢这种字体，看起来代码非常工整。被编辑的行高亮显示。之前Xcode有个插件就是这个功能，Xcode8把高亮功能集成进来了，使用起来很方便。最新版的API文档，展示样式发生了很大的改变。更方便的生成文档(就是喵神写的VVDocumenter)，在Xcode8中可以将光标放在方法上面，通过option + command + /快捷键生成文档注释。 Xcode8适配,XIB和Storeboard适配在 Xcode8 之前，创建一个 XIB 或 SB 文件，都是一个 600*600 的方块 XIB 文件。在 Xcode8 之后，创建的 XIB 文件默认是6s尺寸的大小。 但是 Xcode8 打开之前旧项目的 XIB或SB 文件时，会弹出下面的弹框， 这时候一般直接选择Choose Device即可。 但是这样有个问题，如果Xcode8打开过这个XIB文件，并选择Choose Device之后。其他的Xcode8以下版本的编译器，将无法再打开这个文件，会报以下错误： The document “ViewController.xib” requires Xcode 8.0 or later. This version does not support documents saved in the Xcode 8 format. Open this document with Xcode 8.0 or later.有两种方法解决这个问题： 你同事也升级Xcode8，比较推荐这种方式，应该迎接改变。右击XIB或SB文件 -&gt; Open as -&gt; Source Code，删除xml文件中下面一行字段。 编译错误升级Xcode之后，Xcode8对之前的一些修饰符和语句不兼容，会导致一些编译错误。这种错误导致的原因很多，这里大致列几条，各位还是根据自身遇到的情况做修改吧。 之前一些泛型相关的修饰符，nullable之类的有的会报错。CAAnimation及其子类，设置代理属性后，必须在@interface()遵守代理，否则报错，等等。 权限适配这应该算iOS10系统适配的范畴，最近这两个都在弄，所以就直接和Xcode8适配一起写出来了。 在iOS10之后需要在Info.plist中，添加新的字段获取权限，否则在iOS10上运行会导致崩溃。下面是一些常用的字段，如果有缺少的麻烦各位评论区补充一下。 Key 权限Privacy - Camera Usage Description 相机Privacy - Microphone Usage Description 麦克风Privacy - Photo Library Usage Description 相册Privacy - Contacts Usage Description 通讯录Privacy - Bluetooth Peripheral Usage Description 蓝牙Privacy - Location When In Use Usage Description 定位Privacy - Location Always Usage Description 后台定位Privacy - Calendars Usage Description 日历 参考资料：developer.apple 推送通知苹果的推送在之前iOS8和iOS9的时候就发生过大的更新，推送功能越来越强大。在iOS10之后苹果推出了UserNotifications框架，可以通过这个框架更好的控制推送通知，可以更新、修改锁屏页面的推送消息，可以添加图片等功能。 但是在用Xcode8打包后，并且不对代码进行修改的情况下，会发现打包后苹果发来了一封邮件。这封邮件大概意思是如果需要使用推送通知，需要对代码做修改，否则将不能使用推送通知。 这是因为在Xcode8之后，如果需要使用Push Notifications的功能，需要勾选Capabilities -&gt; Push Notifications为YES，否则进行远程推送就会有问题，并且会收到苹果发来的这封邮件。 删除系统log升级Xcode8之后，在调试和运行过程中，发现控制台打印了很多不认识的log，这些log是系统打印的，和开发者没关系。但是这么多log看着比较乱，怎么屏蔽掉呢？ subsystem: com.apple.UIKit, category: HIDEventFiltered, enable_level: 0, persist_level: 0, default_ttl: 0, info_ttl: 0, debug_ttl: 0, generate_symptoms: 0, enable_oversize: 1, privacy_setting: 2, enable_private_data: 0在Target -&gt; Edit Scheme -&gt; Run -&gt; Arguments中，添加OS_ACTIVITY_MODE字段，并设置为Disable即可。 顺便提一下，这两天在设置log选项的时候，发现可以通过在Arguments中设置参数，打印出App加载的时长，包括整体加载时长，动态库加载时长等。 在Environment Variables中添加DYLD_PRINT_STATISTICS字段，并设置为YES，在控制台就会打印加载时长。 awakeFromNib报警告老项目在Xcode8中，有些重写awakeFromNib方法的地方，会报下面的错误。这是因为没有调用super的方法导致的，还好我平时都是调用super的，我代码目前还没出问题。 1Method possibly missing a [super awakeFromNib] call]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS设备左下角出现Appicon]]></title>
    <url>%2F2016%2F09%2F23%2F2016-09-23-iOSLowerLeftAppicon%2F</url>
    <content type="text"><![CDATA[最近发现我设备锁屏后，按Home屏幕变亮的时候，左下角出现一个灰色的Appicon （应用图标），关于这个应用图标的出现做了一些调研，下面是应用图标出现的几种情况。 图一 iOS 系统自带的 App icon , 图二 第三方 App icon , 图三 通过 iBeacon 信号激活的 demo icon 结论：有三种情况导致设备的左下角出现灰色的 App icon1、AppStore根据地点对App 推荐 简介 iOS 8会基于你的位置在锁屏界面上展示一个app快捷打开方式。比如你正在星巴克附近，那iOS 8会在锁屏界面上展示星巴克应用的icon，方便你快速打开。一些用户也表示会在锁屏界面收到app推荐，比如你在Costco和Apple Store附近，即便你之前没有安装过这些应用。 2、App实现了handoff功能 handoff简介： OS X 10.10 Yosemite 新增了一个酷炫的功能 “Hand Off”，打开这个功能之后，用户可以在 Mac 上对 iPad 和 iPhone 进行操作，比如能够编写 iPhone 上未完成的邮件，并且可以在Mac上打开 iPhone 的热点等等， Mac 的 Hand Off 功能只能识别 Mac 周围的 iPhone 手机。 handoff有几个要求： 1 两台设备都要登录同一个 iCloud 账号。 2 两台设备上的app有相同的 TeamID 。 3 锁屏（或dock）设备上的app支持的 NSUserActivityTypes 包含活动设备上的app当前的UserActivityType。 3、App内有iBeacon信号接收功能，App被iBeacon信号唤醒 iBeacon简介： 是苹果公司2013年9月发布的移动设备用OS（iOS7）上配备的新功能。工作原理类似之前的蓝牙技术，由 iBeacon 发射信号，iOS设备定位接受，反馈信号。根据这项简单的定位技术可以做出许多的相应技术应用,如：室内定位 、商品推荐 、微信摇一摇 等。 App icon出现的原因： iBeacon 具备后台定位的能力，只要用户把蓝牙(4.0或以后)开启 和 允许 App 访问位置信息。在有被 App 检测的 iBeacon 出现时，如果设备是锁屏状态，设备的左下角就会出现该 App 的 icon 。 参考链接:Make app appear as iOS 8 Suggested App at lockscreenCan I get my iOS app to appear on the lower left corner of the lock screen?为什么 iOS 8 锁屏界面的左下角经常会出现某个应用的小图标？关于 IOS8 锁屏左下方出现的 APP ICON]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老司机带你剖析无码统计]]></title>
    <url>%2F2016%2F07%2F15%2F2016-07-15-Codeless%2F</url>
    <content type="text"><![CDATA[无需开发介入，也可以统计移动App上按钮的点击次数，简称 无码统计 ，只要是跟App开发相关的同学，相信都对埋点统计有些了解，特别是针对开发人员来说，做代码埋点统计基本上是看不到直接收益也是开发人员最不愿做的一件事，这篇文章讲的就是如何让开发人员摆脱代码埋点的痛苦。 文章主要分为：使用场景、实现原理、适用范围、使用详情四个模块，不管你是产品，还是开发人员又或者是运营人员都适合读这篇文章。 在App开发过程中我们应该都有过类似的需求：想统计某些按钮的点击次数。例如，我们开发了一个注册模块，注册流程有些复杂，整个注册功能开发完成后，我们想知道到底有没有用户使用注册功能，而又有多少用户使用？ 有什么方式能知道呢？ 后台看注册系统? 有些麻烦，需要后台去数据库里查看，还要做成数据可视化的才方便看。 查看注册按钮的点击情况? 这是最直观的。 主看看两块就行，注册按钮的点击次数 和 提交注册按钮的点击次数，如果发现注册按钮被点击多次（如1W次），而提交注册的点击次数却只有几次，这就可以反映出，很多用户看到的我们的注册流程太复杂，然后选择放弃注册了。同样的道理，我们通过同样的方式可以验证我们其它的功能模块是否有用户经常使用，从而来重新规划我们的设计需求。 一整个功能模块的完成涉及到 产品、UI设计、开发、测试 等几个部分，资源和人力的消耗还是挺大的，所以我们在开发过程是否继续维护这些功能模块，还是开发新功能是要经过慎重衡量，而衡量这些最有说服力的依据就是用户的使用数据，这些数据来源是刚才说的 按钮的点击次数，页面的停留时长 等等。 使用场景 分析用户App的使用情况当然是直接用数据说话，那么想知道某些按钮的点击次数，就一定需要App的开发人员去具体的按钮点击方法里面埋点才行，有的公司有自己的一套完整的统计埋点系统，有的公司是使用第三方统计，最终都是可以看到按钮的点击次数的，不管怎么样想知道按钮的点击必须要App的开发人员亲自去写代码埋点才行，而这篇文章主要讲的是 无码统计 按钮点击次数。也就是不需要开发介入，我们就能知道按钮的点击了，开发人员只要负责他的业务开发就行，下面是一张 传统埋点 统计和 灵动分析 统计，灵动是TalkingData的SDK无码统计的一个功能。 先大致讲下左边 传统 埋点统计流程 首先需要制定埋点需求、设计埋点方案，需求有了后就去找开发沟通，埋点需求的讨论，双方确认需求通过后，然后准备需求文档，开发再根据文档来写具体的埋点代码。 代码写完后，App打包给测试人员，测试人员进行测试，同时还要对埋点参数的数据安全审核，参数是否有包含公司敏感信息。 测试通过后就需要上线了，这个过程一般是开发人员去完成的。iOS需要提交到AppStore上，以前大家都知道，一个审核周期就是一两周，还有随时被拒的可能，现在虽然周期变短了，但审核也还是挺严格的（走快捷通道的除外）。Android需要在各个渠道上重新发布，也是很麻烦的。 如果前面几部都顺利完成了的话，接下来就等待用户更新了，如果埋点统计功能跟其它新功能一起上线的话，我们更新就有理由了，如果仅仅这一版仅仅只是埋点统计功能，那么让用户更新App的理由又是一件头疼的事情了，不管怎么样经常让用户更新App多少会对用户用些影响的。 最终的结果应该是部分用户更新了App，那么我们能统计到按钮点击的用户了就只是更新了App的这一部分用户了，而且他们更新的时间是不一样的，最终我们终于可以看需求上的埋点统计了。 再看看右边 灵动 统计流程 同样需要制定需求，但是需求方可以直接根据自己的需求去使用 灵动 了，使用了灵动就可以直接看按钮的点击率了，这个过程不需要开发介入，也不需要用户去更新App。 从这张图可以看出，不需要开发人员介入，可以开发成功，提高开发效率，而且埋点也很灵活，需求人员（可以是产品，也可以是运营）可以直接使用灵动，也不需要用户更新，那么数据反馈会比传统埋点快很多，使用了就可以立即生效，需求方的观察周期也缩短了，能更灵活的做出决策。 实现原理 上面大致介绍了下 灵动 能给我们解决什么问题，这里讲的是 灵动 是通过什么样的技术手段实现，这里可能对于开发人员来说更喜欢，大家先看一张灵动使用时的一个交互 这张图分成两部分看，先看上面，一个用户在操作Client和PC，Client和PC通讯是通过一个Wss的服务器建立的长连接，这是灵动调试时的一个交互。 也就是说，用户使用灵动分析时，需要一个安装自己App的移动设备，这个App必须要集成TalkingData的统计分析SDK才行，SDK初始化时的AppID是在TalkingData创建应用时分配的。另一端用户要打开TalkingData的灵动网页，在App启动的时候摇一摇手机，然后就可以建立一个wss的长连接了。用户就可以直接在网页上给按钮添加监听事件了，添加完成后，在手机上点击该按钮，网页上就会提示被点击，调试完成后点击全部生效，配置数据就会保存到下面https的服务器。 我们的所有用户在启动App的时候，都可以从https服务器里获取到这套配置，客户端根据这套配置找到具体的按钮，监听点击事件，当按钮被点击后，就可以统计到了。 接下来再看看灵动调试过程中数据是具体怎么进行数据交互的。 可以看到App客户端和Web端交互主要分为四部分：设备信息 、 App基本结构 、控件绑定配置 、按钮点击信息 ，设备信息 主要是用来确认设备是调试者的设备，因为其它的终端用户也可能会误触发调试，App基本结构是用来在Web上展示移动App的，然后在Web上绑定了控件，就会把控件绑定配置发送给客户端，客户端根据配置监听绑定，当终端用户点击控件后，客户端就会把按钮点击信息传给Web端，Web显示控件被点击。 再回头看看实现原理的第一张图片，调试完成数据就会从WSS的长连接服务器存储到HTTPS的服务器，此后其它终端用户只要在再次启动App就能获取到埋点配置了，SDK根据埋点配置去找到具体的控件(按钮)，监听点击，当用户点击控件时就可以调用自定义埋点的方法，之后的数据处理就跟自定义埋点是一样的原理了。 可能有同学会有疑问，所有的App每次启动的时候都会去获取埋点配置，是不是会很耗流量？ 答案是不会的，服务器在没有埋点配置的时候每次将获取不到信息，那么将不会有什么流量消耗。如果服务器有配置了，App才会有些流量消耗的，而且这些配置信息是经过压缩的，所以流量消耗也不大，App获取到了配置之后就会做本地缓存，服务器配置不变的情况下再次获取配置也不会有流量的消耗，只有在下一次运营人员修改了新的控件绑定时才会消耗一些流量。 所以整个无码统计对终端用户的流量的影响是很小的。 你也可以参考这套逻辑试试自己也部署这么一套无码统计，之后就不用再担心运营给的埋点统计需求了，让他们自己去用无码统计吧。]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git教程]]></title>
    <url>%2F2016%2F07%2F13%2F2016-07-13-GitTutorial%2F</url>
    <content type="text"><![CDATA[介绍 Git是做项目的版本管理，你也可以称它们为版本管理工具。假如现在你有一个文件夹，里面可以是项目，也可以是你的个人笔记(如我这个博客)，或者是你的简历、毕业设计等等，都可以使用git来管理。 目前常用的版本控制器有Git和SVN，即使这两个你没有全用过，至少也会听过，我这里以Git为例，个人比较喜欢Git，你也可以看看这篇文章：为什么Git比SVN好。我使用的是Mac，Mac上没自带Git环境，但是作为iOS开发者，我安装Xcode的时候，Xcode里是有自带Git的，所以我不需要考虑怎么去安装Git了。 安装Git在Mac OS X上安装Git 提供两种方法参考： 1、通过homebrew安装Git，具体方法请参考homebrew的文档2、直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode。 在Windows上安装Git 从https://git-for-windows.github.io 下载，然后按默认选项安装即可，安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 配置Git安装完成后，还需要最后一步设置，在命令行输入： $ git config –global user.name “Your Name” $ git config –global user.email “email@example.com“ “Your Name”： 是每次提交时所显示的用户名，因为Git是分布式版本控制系统，当我们push到远端时，就需要区分每个提交记录具体是谁提交的，这个”Your Name”就是最好的区分。 “email@example.com“： 是你远端仓库的email –global：用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然我们也可以对某个仓库指定不同的用户名和Email地址。 开始使用-建立仓库：你在目标文件夹下使命令： git init （创建.git文件） 就会创建一个 .git 隐藏文件，相当于已经建立了一个本地仓库。 添加到暂存区： git add . （全部添加到暂存区） git commit -m ‘ first commit’ （提交暂存区的记录到本地仓库） 其它git branc 查看时如出现 (HEAD detached at analytics_v2) dev master 代表现在已经进入一个临时的HEAD，可以使用 git checkout -b temp 创建一个 temp branch，这样临时HEAD上修改的东西就不会被丢掉了。然后切换到 dev 分支上，在使用 git branch merge temp，就可以把 temp 分支上的代码合并到 dev 上了。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我们日常生活中的 iBeacon]]></title>
    <url>%2F2016%2F04%2F06%2F2016-04-07-iBeacon%2F</url>
    <content type="text"><![CDATA[随着低功耗蓝牙的推出，iBeacon 的使用是越来越广泛了，如：微信的附近摇一摇功能，又或者是当你进入大型商场，一些店铺给你推送通知，VR 场景识别等等，这些表示 iBeacon 已经与我们的生活精密相连了。 简介： 概念： iBeacon 是 iOS7 后苹果出的一项新技术，支持蓝牙4.0(或以上)的 iOS 设备，工作方式是低功耗蓝牙（Bluetooth Low Energy），向周围发送自己特有的ID，一个 iBeacon 硬件设备在不做任何处理的情况下一般可使用两三年左右。 iBeacon 的形状多种多样，大致如下图。 目前哪些地方有 iBeacon： 1、微信摇一摇：使用微信的人应该都知道微信有一个 周边摇一摇 功能， 使用的就是 iBeacon 技术。 很多餐馆都部有 iBeacon 的点，如果你想验证直接监测微信的 iBeaconUUID：FDA50693-A4E2-4FB1-AFCF-C6EB07647825。 2、走进某个商场时，忽然手机里推出一个通知，也是使用 iBeacon 技术。 3、帝都的地跌站大部分也有微信 UUID 的 iBeacon 发射器，具体是用来做什么的还不是慢清楚。 4、iBeacon 还可实现地理围栏、室内定位等功能。 iBeacon 技术 Apple的 CoreLocation.frame 里把iBeacon封装成了一个 CLBeacon 类，CLBeacon 大致有下面几个属性组成：Major 、Minor 、 proximity 、 rssi 、 accuracy 。 开发者如何使用 iBeacopn?: 1、用户需要添加 CoreLocation.framework ，App 才具备定位的功能。 2、App 开发者需要开启定位功能需要配置：在 Xcode 的 info.plist 里面添加 NSLocationAlwaysUsageDescription(允许后台访问位置信息) 或 requestWhenInUseAuthorization(允许使用时访问位置信息) 字段。（iOS7后该添加了该字段应用才会弹出 `是否允许应用访问用户的位置信息）。 创建和注册一个beacon区域 123456789- (void)registerBeaconRegionWithUUID:(NSUUID *)proximityUUID andIdentifier:(NSString *)identifier&#123; CLBeaconRegion *beaconRegion = [[CLBeaconRegion alloc] initWithProximityUUID:proximityUUID identifier:identifier]; [manager startMonitoringForRegion:beaconRegion];&#125;``` 当接受到 iBeacon 信号时回调 ，beacons 里面装了信号的对象，可能同时出现多个信号。 (void)locationManager:(CLLocationManager )manager didRangeBeacons:(NSArray )beacons inRegion:(CLBeaconRegion *)region{ }` Note: 苹果iBeacon官方代码例子。 iBeacon 硬件设备条件： 用户设备 iOS7 或更新操作系统。 用户蓝牙设备4.0或更新。 用户蓝牙设备必须开启。 用户设备定位服务必须开启，允许应用访问位置信息。 iBeacon 能唤醒应用 前提：App 具备上面使用 iBeacon 的功能，并且允许后台访问位置信息。 现象：App 能被 iBeacon 信号唤醒，即使 App 已经被用户手动杀死掉了，App 也能被 iBeacon 技术唤醒，并且能执行一系列操作。 影响：导致 App 用户在并没有使用 App 的情况下, App 有了长达几个小时的后台使用时长。]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 9 变化笔记]]></title>
    <url>%2F2015%2F09%2F26%2F2015-09-26-iOS9_Note%2F</url>
    <content type="text"><![CDATA[这里将介绍下我们日常开发一些从iOS8过度到iOS9给我们带来的一些变化，及解决方法。 App Transport SecurityiOS9和OS X El Capitan的一个新特性，App Transport Security 的目地是提高Apple 操作系统的安全性以及在此操作系统上运行的任何应用的安全性。ATS是苹果针对与 NSURL这一层做的封装，iOS9后ATS默认是开启的，即网络传输需要使用HTTPS。如果想在iOS9后继续使用HTTP的话，有两条路可以走： 在Info.plist中添加 NSAppTransportSecurity类型Dictionary，在NSAppTransportSecurity下添加NSAllowsArbitraryLoads，Boolean 为 YES。 直接使用CFNetwork做网络请求，ASIHTTPRequest就是基于CFNetwotk做的封装，如果有需求的同学可以看看ASI里面的源码，如果某个时间段你又想要使用HTTPS的话，ASI对SSL/TSL的证书验证有点问题，证书验证还得自己封装一下才行。刚才我说道，ATS是苹果针对与NSURL这一层做的封装，所以我们使用CFNetwork或者更底层做网络请求的话是不受ATS限制的。 移除了discoveryd DNS解析服务iPhone升级到iOS8后WiFi有时候会有问题，特别是Mac升级到OS X Yosemite后，时而电脑休眠唤醒唬就连不上WiFi，有时候还突然掉线，经常要手动去关闭WiFi在重新连接，这是因为苹果到了OS X Yosemite系统后，把之前的mDNSResponder换成了discoveryd DNS。iOS9和OS X Yosemite10.4后mDNSResponder又回来了。 mDNSResponder： 苹果以前一直使用控制DNS和Bonjour服务的一种进程。discoveryd：OS X Yosemite后苹果新出的一种进程。 App ThinningApp Thinning是一个关于节省iOS设备存储空间的功能，它可以让iOS设备在安装、更新及运行App等场景中仅下载所需的资源，减少App的占用空间，从而节省设备的存储空间。 App Thinning主要有三个机制： Slicing： 开发者把App安装包上传到AppStore后，Apple服务会自动对安装包切割为不同的应用变体(App variant)， 当用户下载安装包时，系统会根据设备型号下载安装对应的单个应用变体。 On-Demand Resources： ORD(随需资源)是指开发者对资源添加标签上传后，系统会根据App运行的情况，动态下载并加载所需资源，而在存储空间不足时，自动删除这类资源。 Bitcode：开启Bitcode编译后，可以使得开发者上传App时只需上传Intermediate Representation(中间件)，而非最终的可执行二进制文件。 在用户下载App之前，AppStore会自动编译中间件，产生设备所需的执行文件供用户下载安装。 其中，Bitcode的机制可以支持动态的进行App Slicing，而对于Apple未来进行硬件升级的措施，此机制可以保证在开发者不重新发布版本的情况下而兼容新的设备。Xcode7默认是开始了Bitcode，如果不想使用可以手动关闭Bitcode： 选择项目——&gt;点击Target——&gt;点击Build Setttings——&gt;搜索栏里搜bitcode——&gt;把Enable Bitcode对应的Yes改成No。 启用Bitcode编译机制，需要注意以下几点： 如果应用开启Bitcode，那么其集成的其他第三方库也需要是Bitcode编译的包才能真正进行Bitcode编译 开启Bitcode编译后，编译产生的.app体积会变大(中间代码，不是用户下载的包)，且.dSYM文件不能用来崩溃日志的符号化（用户下载的包是Apple服务重新编译产生的，有产生新的符号文件），使用dSYM来收集Crash日志的同学得注意了。 通过Archive方式上传AppStore的包，可以在Xcode的Organizer工具中下载对应安装包的新的符号文件 后台定位iOS9后苹果为了对保障用户的地理位置的隐私对App请求后台定位有了权限设置，则需要多加一些代码。如果不适配iOS9，就不能偷偷在后台定位，如果没有后台定位的权限也是可以在后台定位的，只是会出现蓝条。 开启后台定位功能：locationManager.allowsBackgroundLocationUpdates = YES;locationManager是CLLocationManager的对象，用来管理整个定位的。 重点： 配置info.plist，添加一个Required background modes，Array类型的，然后在Required background modes里面Item 0对应的Value设置为App registers for location updates，这样就解决了iOS9后台定位出现蓝条的问题了。 UI TestingXcode7中苹果引入了一种新的方式在应用中进行测试——UI Testting，UI Testting允许我们找到UI元素与之交互，还能检查属性和状态。UI Testting已经完全集成进了Xcode7的测试报告，可以和单元测试一起执行。使用起来跟之前Xcode5出来的XCTest差不多，Xcode bots提供对此的支持，而且command line支持当UI测试失败时会立即发出通知。 可以参考Github上的Demo，步骤： 在DemoTests.m里创建一个test开头的方法 在setUp()里启动应用 XCUIApplication().launch() 新建一个方法test开头的，在里面获取应用let app = XCUIApplication() 的到let app = XCUIApplication()，app.buttons[“View Detail”].tap()?。buttons是当前这个界面的所有按钮的集合，[]里面写按钮的名字，tap()就是执行这个按钮所对应的方法，可以是网络请求、界面跳转等等。 URL scheme在iOS9中，如果使用URL scheme必须在”Info.plist”中将你要在外部调用的URL scheme列为白名单，否则不能使用。 配置info.plist，添加一个LSApplicationQueriesSchemes，Array类型的，然后在LSApplicationQueriesSchemes的Item里面添加urlscheme就行了，urlscheme是任意一个字符串，就是你自己需要使用的urlscheme，iOS9 URL scheme白名单适配就完成了。 出现大量的警告Xcode7后运行以前的项目后出现大量的警告如： 1(null): warning: /var/folders/p4/z7zy68r92hd3p5ry5g2v3k_8rlwzzr/C/org.llvm.clang.dalmo/ModuleCache/1TXZDLI9N2EMV/Foundation-3DFYNEBRQSXST.pcm: No such file or directory。 作为一个有洁癖的我反正是不能忍，出现警告的大致原因跟我上面提到的开启Bitcode，.dSYM文件不能用来符号化有关，Xcode试图去创建dSYM文件，但是你又不需要。 解决方法 Build Settings ——&gt;Build Options——&gt;Debug Information Format Debug下的DWARF with dsYM File改成DWARF Release下的还是之前默认的DWARF with dsYM File不变 参考资料： iOS9AdaptationTips iOS9学习系列 iOS9-day-by-day]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iso]]></title>
    <url>%2F2015%2F08%2F25%2F2016-01-09-iOS_OTA%2F</url>
    <content type="text"><![CDATA[1、控件到 window 的层级关系: 2、分析控件的详细路径: 3、动态修改控件: 4、工具篇: 视图的层级关系每个 App , 至少有一个根 Window , 通常情况下我们只用一个 。window 有一个 rootViewController , 这就是我们所谓的根视图 , 我们所有的控制器都是放在 rootViewController 里面的。 如果在项目里有了这么一个路径 , 我们可以做什么呢？ 在当项目很复杂 , 可以其它地方可以直接修改这个控件的状态 当某个控件命名存在却又没有显示出来 , 可以通过路径来辅助查找 由服务器下发一些配置 , 使用 Runtime 去动态的修改已上线的项目 下面将介绍如何使用代码来找出这些视图(控件)的路径 分析控件的详细路径1、找出根 Window :每一个视图、控件 , 他们最终的根都是main函数返回的 application , 通过 [UIApplication sharedApplication] 可以得到 。 application 的 windows 属性是一个数组 , 这里面装的是这个应用的所有 Window , 我们通常用的是第一个也就是 application.windows[0] 2、遍历视图 :得到了 window 对象一切都好办了 。 然后拿到 window 的 rootViewController , 在获取 rootViewController 里面所有的 childViewControllers 和 view 里的 subviews , 一直递归下去就可以得到当前屏幕里所有视图对象了 , 同时可以通过 runtime 把它们的 property、delegate 都获取出来。 结合 Reveal 或者 Xcode 自带的 Captuer View Hiearachy , 我们可以推测一下这两个的的实现原理了 : 1、根据应用得到根视图2、递归获取里面的所有控件3、按照他们的层级关系一层一层的画出来 动态修改控件1、把上面获取到的所有控件的详细信息上传到服务器 。2、根据业务需求由服务器给我们下发对应的配置列表，以 button 为例 : 配置列表里必须要有 : 1)、button 的全路径 : 如 UIWindow -&gt; UIWindow -&gt; UIView -&gt; UIView -&gt; UILayoutContainerView -&gt; UITabBar -&gt; UIView —&gt; UIButton 2)、button 的唯一标识 : 如 tag 值或自己实现的一套算法生成的唯一标识 , 目的是防止与 button 同一层次的视图搞混 。 3)、 根据路径及唯一标识来匹配 App 里的控件 , 匹配和上面的查找原理是相通的。 4)、 匹配成功代表 button 确实存在 , 根据业务需求做后续操作 。 提示: 匹配策略尽可能的多 , 防止意外情况某一两个标识生成失败或者生成相同 。 3、修改 button 的状态。 1)、 如某个按钮点了会 Crash 或暂时不需要被点击 , 但是又要展示出来 , 可以直接修改 button 的 enabled 属性 。 2)、 如某业务暂时关闭 , 可以直接修改入口 按钮 frame为0 , 前提是要自动布局已做好 。 3)、 如给购买 按钮 添加监听事件 addTarget: action: forControlEvents: target 也可以通过上面 遍历视图 获取到 , action 可以由服务器下发 , 也可以一开始就写死 , 等有需求的时候直接传不同的参数就行了 。 4、 绑定查找控件时 , 这个界面必须要已经初始化完成了才行 , 假如界面还没生成肯定是查找不到这个控件的 。 这里给大家提供两种思路 : 1、使用Runtime Method Swizzing , 直接把修改控件的方法与 didMoveToSuperview 和 didMoveToWindow 动态绑定 , 等这个控件加载出来之后再去修改 , 查找路径正确的话肯定就能找到了 。 2、在具体的类里面 , 等控件的初始化方法调用完后 , 再去执行动态修改 , 如在viewDidLoad 里面初始化控件 , 在 viewWillAppear: 里面动态修改 。 建议使用第一种适用范围更强 。 上架后的 应用 可能会遇到的一些突发状况 , 未测出的Crash、临时改点小需求 , 等等 , 我们总不能每次因为一点小改动就重新提交一次 App Store , 先不说 App Store 的审核时间 , 频繁的让用户去更新应用 , 用户也会烦的 。使用这篇文章所讲的来实现动态更新是再合适不过了 。 首先上面讲的 动态更新 是完全脱离出来的一个模块 , 跟业务逻辑没有任何关系 , 只需要部署一次就行了 , 等开发下一个项目也可以直接拿过去使用 。这里的动态更新适用于局部的视图、控件的修改 , 如果你有其它需求可以考虑 JSPatch , 下发脚本也是一个不错的选择 。 工具篇使用一些UI调试的辅助工具 , 使我们查看视图在项目中得层次结构更为方便 。常用的UI调试的工具： Captuer View Hiearachy Reveal Xcode自带的 Captuer View Hiearachy 实现步骤: 1、打开Xcode , 运行项目 , 选择最顶部的 Debug 2、Debug -&gt; View Debugging -&gt; Show View Frames 3、Debug -&gt; View Debugging -&gt; Captuer View Hiearachy Xcode里面就变成了三维的视图了 , Xcode左侧展示出来的是层级关系的树状图 。 Reveal的功能相对来说更强大 , 适用于UI调试视图查找 。使用方法请看 Reveal集成指南 。]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
